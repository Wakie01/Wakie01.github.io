{"meta":{"title":"Wakie's Blog","subtitle":"","description":"Touch the stone and cross the river","author":"Wakie","url":"https://wakie01.github.io","root":"/"},"posts":[{"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wakie01.github.io/tags/Linux/"}],"title":"Ubuntu18.04装载硬盘","date":"2021/06/13","text":"最近服务器又崩了，连接服务器运行jar包，一直显示no space没空间的错误，打开Ubuntu图形化界面才发现，硬盘空间爆了，available空间为0。 于是删了很多10个G的东西，可是df -h命令一看，挂载在根目录下的硬盘分区虽然腾出了一点空间出来，可是Avail还是为0，这时候我以为只是系统不太灵敏，重启一下就好了。 结果，不重启还好，一重启就出事了！！！ 进不了图形界面，等了好久之后，一直显示mysql community server启动失败 后来才意识到，还是硬盘空间的问题，空间不够了！！ 那没办法了，只能继续删了，先进去图形界面再说。 解决办法： 进入recovery模式，删除无用文件，释放磁盘空间。 重启Ubuntu，随即长按shift进入grub菜单 在grub菜单中，选择recovery mode，回车确认 在Recovery Menu中，先选择clean，清理一下磁盘空间，同时也可以获取读写权限 选择resume重启系统 要是还是这个问题的话，重复1、2、3步骤 选择root，输入root密码，进入root shell命令窗口 使用rm -rf命令删除文件，在删除时注意使用df -h查看磁盘各个区的使用情况 输入reboot命令重启系统 折腾了一上午，终于重回图形界面了，接着就是给服务器装载硬盘了。 在这里我使用的方法是图形界面法：Disks软件 由于服务器之前就插入了一块硬盘，所以我直接在Disks上面弄就好了 步骤： 对新磁盘的每个分区都进行格式化Format partition（在这里只有一个分区） 在想要挂载的地方建立一个文件夹，该文件夹的命名为刚刚磁盘卷的名字（比如这里为Disk2_21GB） 设置挂载目录 注意Mount Point的路径要与刚刚建立的目录对应起来 挂载磁盘 完成挂载 参考： ubuntu磁盘满导致无法开机 【Linux】Linux下挂载新硬盘（图形化使用Ubuntu自带Disks）","permalink":"https://wakie01.github.io/2021/06/13/1747/","photos":[]},{"tags":[],"title":"WinSCP连接Ubuntu服务器网络错误","date":"2021/05/14","text":"今天用WinSCP连接Ubuntu服务器网络错误，就卡在第一步，都没验证用户名是否正确 查了一下，才发现原来Ubuntu太干净了，都没装SSH服务 所以需要安装和配置SSH服务","permalink":"https://wakie01.github.io/2021/05/14/null/","photos":[]},{"tags":[{"name":"linux","slug":"linux","permalink":"https://wakie01.github.io/tags/linux/"}],"title":"ubuntu安装与配置JDK8","date":"2021/05/11","text":"先去Oracle官网下载jdk8的压缩包 比如下载的文件是：jdk-8u291-linux-x64.tar.gz 创建目录： sudo mkdir /usr/local/java 然后解压到该目录下： sudo tar -zxvf jdk-8u291-linux-x64.tar.gz /usr/local/java 这时解压后得到的文件夹是jdk1.8_291 打开环境变量文件： sudo gedit /etc/profile 这里若是找不到gedit命令的话，就先安装gedit sudo apt-get update sudo apt-get install gedit-gmate sudo apt-get install gedit-plugins sudo apt-get remove gedit sudo apt-get install gedit 在该文件的最后添加以下内容： #Jdk ConfigJAVA_HOME=/usr/local/java/jdk1.8_291JAVA_BIN=/usr/local/java/jdk1.8_291/binPATH=$PATH:$JAVA_BINCLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME JAVA_BIN PATH CLASSPATH 保存文件，让环境变量生效： source /etc/profile","permalink":"https://wakie01.github.io/2021/05/11/1938/","photos":[]},{"tags":[{"name":"linux","slug":"linux","permalink":"https://wakie01.github.io/tags/linux/"}],"title":"ubuntu安装mysql8","date":"2021/05/11","text":"去mysql官网上获取apt安装包 复制下载地址，比如：https://dev.mysql.com/get/mysql-apt-config_0.8.17-1_all.deb 运行下面命令： wget https://dev.mysql.com/get/mysql-apt-config_0.8.17-1_all.deb 该命令会默认将mysql安装包下载到当前目录 到mysql安装包目录下运行： sudo dpkg -i mysql-apt-config_0.8.17-1_all.deb 默认选择OK 更新APT软件仓库： sudo apt-get update 安装mysql server： sudo apt-get install mysql-server 在该过程中会配置root密码 然后就到这里 这里Tab回车OK 然后配置身份认证方式，默认即可 然后就安装完成，这时候所有的服务、环境变量都会启动和配置好，无须手动配置。 服务管理： 查看服务状态 sudo service mysql status 停止服务 sudo service mysql stop 启动服务 sudo service mysql start 重启服务 sudo service mysql restart 问题问题一： 刚安装好mysql8时，用ip地址连接mysql时，可能会有如下问题： 解决：修改mysql数据库中的user表 mysql -uroot -p -- 登录use mysql; -- 连接mysql schemeselect user,host from user; update user set host='%' where user='root'; -- 原来host字段是localhost,root用户只能被本地连接flush privileges; -- 刷新 再不行的话就重启mysql sudo service mysql restart","permalink":"https://wakie01.github.io/2021/05/11/1709/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"Java不常见运算符","date":"2021/04/18","text":"最近碰到了一些奇奇怪怪的运算符，不认识，结果被吐槽基础太差了 Java运算符主要分为以下几大类： 算术运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 算术运算符就是常用的 + - * / % ：求余 ++ -- 关系运算符也是常用的 == != > >= >> ：按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 例子： public static void main(String[] args) { int A=60; int B=13; System.out.println(\"A: \"+Integer.toBinaryString(A)); System.out.println(\"B: \"+Integer.toBinaryString(B)); System.out.println(\"A&B: \"+Integer.toBinaryString(A&B)); System.out.println(\"A|B: \"+Integer.toBinaryString(A|B)); System.out.println(\"A^B: \"+Integer.toBinaryString(A^B)); System.out.println(\"~A: \"+Integer.toBinaryString(~A)); System.out.println(\"A2: \"+Integer.toBinaryString(A>>2)); System.out.println(\"A>>>2: \"+Integer.toBinaryString(A>>>2));} 结果： 参考： java运算符 与（&）、非（~）、或（|）、异或（^） Java 运算符-菜鸟教程","permalink":"https://wakie01.github.io/2021/04/18/2127/","photos":[]},{"tags":[{"name":"PS","slug":"PS","permalink":"https://wakie01.github.io/tags/PS/"}],"title":"PS制作金属字","date":"2021/04/17","text":"题目制作类似这样的金属字 解题 打开背景 选择横排文字工具，添加名字图层，适当修改文字样式 分别按Ctrl+j拷贝两个文字图层，并将拷贝图层都设置为不可见 右击Hu Wen图层，点击混合选项，点击斜面和浮雕，将深度设置为400%，然后点击渐变叠加，点击渐变，调整渐变编辑器，然后点击描边，大小为5像素，位置居中，填充类型为渐变，点击渐变，调整渐变编辑器，然后点击内发光，并调整内发光相关配置，然后点击光泽，并调整光泽相关配置，然后点击外发光，并调整外发光相关配置，然后点击投影，并调整投影相关配置，点击斜面和浮雕继续调整 对胡雯图层也做同样的操作","permalink":"https://wakie01.github.io/2021/04/17/0935/","photos":[]},{"tags":[{"name":"PS","slug":"PS","permalink":"https://wakie01.github.io/tags/PS/"}],"title":"重温PhotoShop","date":"2021/04/17","text":"PS快捷键 Ctrl+j ：拷贝图层 Ctrl+t ：自由变换，即自由拉伸、旋转，不加Shift就按比例拉伸，加则可以任意拉伸拉伸 Alt+Ctrl+E ：盖印图层，把所有（默认，也可将选择的）图层拼合后的效果变成一个图层,但是保留了之前的所有图层 Ctrl+D ：取消选择，即取消选择选区 Ctrl++ ：放大图像 Ctrl+- ：缩小图像","permalink":"https://wakie01.github.io/2021/04/17/1443/","photos":[]},{"tags":[{"name":"PS","slug":"PS","permalink":"https://wakie01.github.io/tags/PS/"}],"title":"使用剪贴蒙版和图层蒙版合成图像","date":"2021/04/16","text":"题目 做法 选择新增图层，然后将图层填充为白色，然后将图层1设置为不可见 使用快速选择工具，选择瓶子，然后鼠标右击点击反选 选择图层1，并将图层1设置为可见，然后选择填充工具，将选择区域填充为黑色 快捷键Ctrl+D 取消选择，并将图层1设置为不可见，选择背景图层 将校园图片拖进PS中，然后对其适当的自由拉伸 点击上方的✔，然后将该图层命名为校园，然后右击该图层，点击转换为图层 将校园图层设置为不可见，选择图层1，将图层1设置为可见，选择快速选择工具，将白色区域选中 选择校园图层，并点击图层工具栏下方的添加图层蒙版 将校园图层设置为可见，删除图层1 将校园图层的不透明度设置为70% 快捷键Ctrl+T将校园图片进行适当的自由拉伸 选择蒙版图层，然后选择画笔工具，然后将前景色设置为黑色，然后对露出来的校园图层进行涂黑 调整画笔不透明度，对蒙版图层的水瓶和风景图片的边缘进行适当的涂黑 将背景图层设置为非锁定，选择背景图层和校园图层，快捷键Alt+Ctrl+E将这两个图层盖印图层，并将盖印图层命名为倒影 快捷键Ctrl+t自由变换倒影图层，右击选择垂直翻转，设置不透明度为30%，拖动倒影图层成水瓶的倒影 对倒影图层添加蒙版，选择蒙版图层，选择矩形选择工具，将倒影中间线往上的地方选中，选择填充工具，对选取填充为黑色 快捷键Ctrl+D取消选择，然后选择倒影中间线往下的地方，选择渐变工具，对选区进行渐变，然后取消选择","permalink":"https://wakie01.github.io/2021/04/16/1121/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"Java注解和反射","date":"2021/03/05","text":"注解Annotation介绍注解Annotation是从JDK5.0开始引入 作用： 注解不是程序本身，它相当于一个标签，对程序进行评价与解释（这一点与注释comment相同） 可以被其他程序（如编译器等）读取 使用： 注解可以附加在package、class、method、field等上面，这就相当于给他们添加了额外的辅助信息，然后我们可以通过反射机制编程实现对这些元数据的访问 内置注解即JDK本身内置的注解 常见内置注解： @Override： 用于修饰方法，表示重写超类的方法 @Deprecated： 用于修饰方法、属性、类，表示不建议使用 @SuppressWarnings： 用于抑制编译时的警告信息 元注解元注解的作用就是负责注解其他注解，这些元注解可在java.lang.annotation包中找到 对于JDK1.8，共有6个元注解： @Document： 说明该注解将被包含在javadoc中 @Inherited： 说明子类可以继承父类中的该注解 @Native： 用于修饰成员变量，表示该变量可以被本地代码引用，常被代码生成工具使用 @Repeatable： 表示允许在相同的程序元素中重复注解，即在一处地方重复使用同一个注解 @Retention： 用于描述注解的生命周期 @Target： 用于描述注解的使用范围 自定义注解几个关键点： 一个注解里只有参数，没有方法 定义注解方法： public @interface 注解名{ //参数} 注解参数格式：参数类型+参数名+(); 可通过default来声明参数的默认值 当注解只有一个参数时，可以使用value当参数名，这样在使用时就可以直接省掉参数名，但若是用别的参数名就不能省了 当注解参数没默认值时，则在使用时，必须给参数赋值（即：注解参数必须要有值） 例子： public class Learn { //当注解参数没默认值时，则在使用时，必须给参数赋值 @Student(id = 1,name=\"Tony\") public void addStudent(){ } //如果想修改默认值时，也可自行赋值 @Student(id=2,name=\"John\",age = 20) public void addStudent2(){ } //当注解只有一个参数时，可以使用value当参数名，这样在使用时就可以直接省掉参数名 @GoodStudent(\"Tony\") public void praiseStudent(){ } //当然也可以不省 @GoodStudent(value = \"Tony\") public void praiseStudent2(){ } //该注解虽然只有一个参数，但参数名不是value，所以不能省 @BadStudent(name = \"Tony\") public void punishStudent(){ }}@Target({ElementType.METHOD,ElementType.FIELD}) //表明注解的使用范围@Retention(RetentionPolicy.RUNTIME) //表明注解的生命周期@interface Student { //注解里只有参数 //注解中的参数格式： 参数类型 + 参数名+ (); int id(); //学生ID String name(); //名字 int age() default 18; //年龄，默认18 String[] schools() default {\"北京小学\",\"北京中学\",\"北京大学\"}; //学校，默认……}//好学生注解@Target({ElementType.METHOD,ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@interface GoodStudent{ //当注解只有一个参数时，可以使用value当参数名，这样在使用时就可以直接省掉参数名，用别的参数名就不能省了 //表示学生名 String value();}//坏学生注解@Target({ElementType.METHOD,ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@interface BadStudent{ String name();} 反射Reflection介绍反射Reflection，是Java被视为准动态语言的关键 动态语言： 是一类在运行时可以改变其结构的语言（就是代码在运行时可被改变） 静态语言： 运行时结构不可变的语言 反射机制允许程序在执行期间借助Reflection API获取任何类的内部信息，并能直接操作任意对象的所有内部属性以及方法 在加载完类之后，JVM的堆内存的方法区会产生一个Class类型的对象（一个类只有一个Class对象），这个Class对象包含了完整的类的结构信息，因此我们可以通过这个对象看到类的结构。所以我们形象地称之为反射 反射用到的主要API是java.lang.Class类与java.lang.reflect包 类加载过程在Java内存中，有以下几个区： 堆： 存放new的对象和数组 可以被所有的线程共享，不会存放别的对象引用 栈： 存放基本变量类型（会包含这个基本类型的具体数值） 引用对象的变量（会存放这个引用在堆里面的具体地址） 方法区： 可以被所有的线程共享 包含了所有的class和static变量 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过以下三个步骤来对该类进行初始化： 类的加载（Load）： 将类的class文件字节码读入内存，并将这些静态数据转换成方法区的运行时数据结构，然后为之创建一个java.lang.Class对象。 此过程由类加载器完成 类的链接（Link）： 将类的二进制数据合并到JVM的运行状态之中的过程。此过程又具体分为三个部分： 验证： 确保加载的类信息符合JVM规范，没有安全方面的问题 **准备： ** 为类变量（static）分配内存，并设置类变量默认初始值，这些内存都在方法区中进行分配 解析： 将虚拟机常量池内的符号引用（常量名）替换为直接引用（地址） 类的初始化（Initialize）： JVM负责对类进行初始化 也就是执行类构造器()方法的过程。类构造器()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器） 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先初始化父类 虚拟机会保证一个类的方法在多线程环境中被正确加锁和同步 Q： 类加载器的作用？ 它的作用是把类(class)装载进内存。 JVM规范定义了如下类型的类加载器： Bootstrap Class Loader： 引导类加载器，用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取 Extension Class Loader： 扩展类加载器，负责把jre/lib/ext目录下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库。该加载器可以获取 App Class Loader： 系统类加载器，负责将java -classpath或-D java.class.path所指目录下的类与jar包装入工作库，是最常用的加载器。该加载器可以获取 Custom Class Loader： 自定义类加载器 例子： public class ClassLoadLearn3 { public static void main(String[] args) throws ClassNotFoundException { //获取系统类的加载器 ClassLoader systemClassLoader=ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); //获取系统类加载器的父类加载器-->扩展类加载器 ClassLoader parent=systemClassLoader.getParent(); System.out.println(parent); //获取扩展类加载器的父类加载器-->根加载器(c/c++) ClassLoader parent2=parent.getParent(); //因为无法获取，所以输出null System.out.println(parent2); //获取当前类是哪个加载器加载的， ClassLoader classLoader=ClassLoadLearn3.class.getClassLoader(); System.out.println(classLoader); //测试JDK内置的类是谁加载的 ClassLoader classLoader1=Class.forName(\"java.util.Objects\").getClassLoader(); //该类属于Java的核心库，是由引导类（根）加载器加载，所以输出null System.out.println(classLoader1); //获得系统类加载器可以加载的路径 System.out.println(System.getProperty(\"java.class.path\")); //会输出以下东西 /* D:\\java\\jdk\\jre\\lib\\charsets.jar; D:\\java\\jdk\\jre\\lib\\deploy.jar; D:\\java\\jdk\\jre\\lib\\ext\\access-bridge-64.jar; D:\\java\\jdk\\jre\\lib\\ext\\cldrdata.jar; D:\\java\\jdk\\jre\\lib\\ext\\dnsns.jar; D:\\java\\jdk\\jre\\lib\\ext\\jaccess.jar; D:\\java\\jdk\\jre\\lib\\ext\\jfxrt.jar; D:\\java\\jdk\\jre\\lib\\ext\\localedata.jar; D:\\java\\jdk\\jre\\lib\\ext\\nashorn.jar; D:\\java\\jdk\\jre\\lib\\ext\\sunec.jar; D:\\java\\jdk\\jre\\lib\\ext\\sunjce_provider.jar; D:\\java\\jdk\\jre\\lib\\ext\\sunmscapi.jar; D:\\java\\jdk\\jre\\lib\\ext\\sunpkcs11.jar; D:\\java\\jdk\\jre\\lib\\ext\\zipfs.jar; D:\\java\\jdk\\jre\\lib\\javaws.jar; D:\\java\\jdk\\jre\\lib\\jce.jar; D:\\java\\jdk\\jre\\lib\\jfr.jar; D:\\java\\jdk\\jre\\lib\\jfxswt.jar; D:\\java\\jdk\\jre\\lib\\jsse.jar; D:\\java\\jdk\\jre\\lib\\management-agent.jar; D:\\java\\jdk\\jre\\lib\\plugin.jar; D:\\java\\jdk\\jre\\lib\\resources.jar; D:\\java\\jdk\\jre\\lib\\rt.jar; D:\\Java workspace\\annotationLearn\\out\\production\\annotationLearn; D:\\IntelliJ IDEA\\IntelliJ IDEA 2020.1.2\\lib\\idea_rt.jar */ }} 结果： Q： 什么是双亲委派机制？有什么作用？ 双亲委派机制是：当某个类加载器需要加载某个.class文件时，它首先会把这个任务委托给它的上级类加载器，递归这个操作，如果上级的类加载器没有加载，该类加载器才会去加载这个类 双亲委派机制作用： 防止重复加载同一个.class 保证核心.class不会被纂改，即使被纂改也不会去加载，这样就保证了.class的执行安全 比如若用户定义一个java.lang.String类，执行的话，该自定义的类是不会被执行的 Q： 什么时候会发生类初始化？ 类的主动引用时，一定会发生类的初始化；而被动引用的话，可能会发生 主动引用有： 当JVM启动时，会先初始化main()方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先初始化父类 被动引用有： 当访问一个静态域时，只有真正声明这个域的类才会被初始化，若是通过子类引用父类的静态变量，不会导致子类的初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 例子： public class ClassLoadLearn2 { static { System.out.println(\"Main类被加载\"); } public static void main(String[] args) throws ClassNotFoundException { //1. 主动引用// Son son=new Son(); //2. 反射也会产生主动引用// Class.forName(\"com.my.reflection.Son\"); //3. 调用父类的静态变量或静态方法，不会产生子类的初始化// System.out.println(Son.b); //4. 通过数组定义类引用，不会触发此类的初始化// Son[] array=new Son[5]; //5. 常量不会引起父类和子类的初始化// System.out.println(Son.M); }}class Father{ static int b=2; static { System.out.println(\"父类被加载\"); }}class Son extends Father{ static int m=100; static final int M=1; static { System.out.println(\"子类被加载\"); m=300; }} 结果1与结果2： 结果3： 结果4： 结果5： 此外，类加载器还是有缓存的 类缓存： 标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。当然JVM垃圾回收机制可以回收这些Class对象 Class类每个对象，通过反射获得一个Class类型的对象，通过这个Class对象可以获得该类中的信息 Class本身也是一个类 Class对象只能由系统建立 一个加载的类在JVM中只会有一个Class实例 一个Class对象对应的是一个加载在JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class实例所生成的 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象 那哪些类型可以有Class对象呢？ 有：class（所有类）、interface（接口）、[]（数组）、enum（枚举）、annotation（注解）、primitive type（基本数据类型）、void public class ReflectionLearn { public static void main(String[] args) { Class c1=Object.class; //类 Class c2=Runnable.class; //接口 Class c3=String[].class; //数组 Class c4=int[][].class; //二维数组 Class c5=Override.class; //注解 Class c6= ElementType.class; //枚举 Class c7=Integer.class; //基本类型 Class c8=void.class; //void Class c9=Class.class; //Class本身 System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); System.out.println(c6); System.out.println(c7); System.out.println(c8); System.out.println(c9); }} 结果： 获取Class类实例先假设有个User类，并且此类位于com.my.reflection包下 已知具体的类，通过类的class属性获取，此方法最为安全可靠，程序性能最高 Class userClass=User.class; 已知某个类的实例，调用该实例的getClass()方法获取 User user=new User();Class userClass=user.getClass(); 已知一个类的全类名（包名+类名），则可通过Class类的静态方法forName()获取，然后这方法可能会抛出ClassNotFoundException Class userClass=Class.forName(\"com.my.reflection.User\"); Java内置的基本数据类型可以直接用类目.Type获取 Class integerClass=Integer.TYPE; 利用ClassLoader 常用方法Class类的常用方法： 方法名 功能说明 static Class ClassforName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造参数，返回Class对象的一个实例 String getName() 返回此Class对象所表示的实体（类、接口、数组类或void）的名称 …… …… 太多了，具体可去 Java文档中的java.lang.Class 看看 例子： package com.my.reflection;public class User { private int id; private String name; private int age; public String school; protected String phone; public User() { } public User(int id, String name, int age, String school, String phone) { this.id = id; this.name = name; this.age = age; this.school = school; this.phone = phone; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getSchool() { return school; } public void setSchool(String school) { this.school = school; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } private void addUser(){ }} package com.my.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ClassLearn { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException { //获取User类 Class userClass=Class.forName(\"com.my.reflection.User\"); System.out.println(userClass.getName()); //获取类的名字 包名+类名 System.out.println(userClass.getSimpleName()); //获取类的名字 类名 //获得类的属性,但只能找到public属性 Field[] fields = userClass.getFields(); System.out.println(\"fields:\"); for (Field field : fields) { System.out.println(field); } //获得类的属性,并且可以找到全部的属性,包括private Field[] declaredFields = userClass.getDeclaredFields(); System.out.println(\"declaredFields:\"); for (Field declaredField : declaredFields) { System.out.println(declaredField); } //获得类的指定属性,但只能是public属性// Field name = userClass.getField(\"name\");// System.out.println(\"nameField: \"+name); //获得类的指定属性,包括private Field name = userClass.getDeclaredField(\"name\"); System.out.println(\"nameField: \"+name); //获得类的方法，其中包括本类及其父类的全部public方法 Method[] methods = userClass.getMethods(); System.out.println(\"methods:\"); for (Method method : methods) { System.out.println(method); } //获得类的方法，不过只是获得本类的所有方法，包括private的 Method[] declaredMethods = userClass.getDeclaredMethods(); System.out.println(\"declaredMethods:\"); for (Method declaredMethod : declaredMethods) { System.out.println(declaredMethod); } //获得类指定的方法,第二个参数是指定方法的参数的类 //第二个参数是用来辨别关于重载的方法的 Method getName = userClass.getMethod(\"getName\", null); Method setName = userClass.getMethod(\"setName\", String.class); System.out.println(); System.out.println(getName); System.out.println(setName); //获得类的全部public的构造方法 Constructor[] constructors = userClass.getConstructors(); System.out.printf(\"\\nconstructors:\\n\"); for (Constructor constructor : constructors) { System.out.println(constructor); } //获得类的全部构造方法,包括private Constructor[] declaredConstructors = userClass.getDeclaredConstructors(); System.out.printf(\"\\ndeclaredConstructors:\\n\"); for (Constructor declaredConstructor : declaredConstructors) { System.out.println(declaredConstructor); } //获得类的指定的构造方法，参数的指定构造方法参数的类 Constructor declaredConstructor = userClass.getDeclaredConstructor(int.class, String.class, int.class, String.class, String.class); System.out.println(); System.out.println(declaredConstructor); }} 结果： com.my.reflection.UserUserfields:public java.lang.String com.my.reflection.User.school declaredFields:private int com.my.reflection.User.idprivate java.lang.String com.my.reflection.User.nameprivate int com.my.reflection.User.agepublic java.lang.String com.my.reflection.User.schoolprotected java.lang.String com.my.reflection.User.phone nameField: private java.lang.String com.my.reflection.User.name methods:public java.lang.String com.my.reflection.User.getName()public int com.my.reflection.User.getId()public void com.my.reflection.User.setName(java.lang.String)public void com.my.reflection.User.setPhone(java.lang.String)public void com.my.reflection.User.setSchool(java.lang.String)public void com.my.reflection.User.setAge(int)public java.lang.String com.my.reflection.User.getSchool()public java.lang.String com.my.reflection.User.getPhone()public int com.my.reflection.User.getAge()public void com.my.reflection.User.setId(int)public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public java.lang.String java.lang.Object.toString()public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll() declaredMethods:public java.lang.String com.my.reflection.User.getName()public int com.my.reflection.User.getId()public void com.my.reflection.User.setName(java.lang.String)public void com.my.reflection.User.setPhone(java.lang.String)public void com.my.reflection.User.setSchool(java.lang.String)public void com.my.reflection.User.setAge(int)public java.lang.String com.my.reflection.User.getSchool()public java.lang.String com.my.reflection.User.getPhone()private void com.my.reflection.User.addUser()public int com.my.reflection.User.getAge()public void com.my.reflection.User.setId(int)public java.lang.String com.my.reflection.User.getName()public void com.my.reflection.User.setName(java.lang.String)constructors:public com.my.reflection.User()public com.my.reflection.User(int,java.lang.String,int,java.lang.String,java.lang.String)declaredConstructors:public com.my.reflection.User()public com.my.reflection.User(int,java.lang.String,int,java.lang.String,java.lang.String)public com.my.reflection.User(int,java.lang.String,int,java.lang.String,java.lang.String)Process finished with exit code 0 例子二： package com.my.reflection;//通过反射，动态地创建对象public class ClassLearn2 { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { //获取User类 Class userClass=Class.forName(\"com.my.reflection.User\"); // 通过User类新建对象，然后强转 // 此方法默认调用类的无参构造方法，若无无参构造方法，会报错，当然如果访问权限不够的话，也会报错 User user=(User)userClass.newInstance(); System.out.println(user); //通过构造器创建对象 Constructor declaredConstructor = userClass.getDeclaredConstructor(int.class, String.class, int.class, String.class, String.class); User user2 = (User)declaredConstructor.newInstance(1, \"Tony\", 20, \"Beijing University\", \"1234566778\"); System.out.println(user2); //通过反射调用普通方法 User user3=(User)userClass.newInstance(); //先获取方法 Method setName=userClass.getDeclaredMethod(\"setName\", String.class); //激活（调用方法），参数一：调用方法的对象，参数二：调用方法所需要的参数 setName.invoke(user3, \"John\"); System.out.println(user3); //通过反射操作属性 User user4=(User)userClass.newInstance(); Field name = userClass.getDeclaredField(\"name\"); //没有的话会报无法访问private属性的错误 //所以说，不能直接操作私有属性，需要关闭程序的安全检查，或者通过属性的getter/setter方法 name.setAccessible(true); //设置属性，参数一：调用方法的对象，参数二：属性值 name.set(user4,\"Wakie\"); System.out.println(user4); }} 结果： 关于setAccessible(boolean flag)方法： Method、Field、Constructor对象都有setAccessible()方法 其作用是启动和禁用访问安全检查的开关 参数flag为true：表示反射的对象在使用时取消Java语言的访问检查；反之则不取消 flag为true有助于提高反射的效率 例子三： package com.my.reflection;//性能测试public class ClassLearn3 { //普通方法调用 public static void test(){ User user=new User(); long startTime = System.currentTimeMillis(); for (int i = 0; i < 1000000000; i++) { user.getName(); } long endTime=System.currentTimeMillis(); System.out.println(\"普通方法调用方式: \"+(endTime-startTime)+\"ms\"); } //反射方式调用 public static void test2() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user=new User(); Class userClass=user.getClass(); Method getName = userClass.getMethod(\"getName\", null); long startTime = System.currentTimeMillis(); for (int i = 0; i < 1000000000; i++) { getName.invoke(user,null); } long endTime=System.currentTimeMillis(); System.out.println(\"反射方式调用: \"+(endTime-startTime)+\"ms\"); } //反射方式调用，关闭安全检查 public static void test3() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user=new User(); Class userClass=user.getClass(); Method getName = userClass.getMethod(\"getName\", null); getName.setAccessible(true); long startTime = System.currentTimeMillis(); for (int i = 0; i < 1000000000; i++) { getName.invoke(user,null); } long endTime=System.currentTimeMillis(); System.out.println(\"反射方式调用，并且关闭安全检查: \"+(endTime-startTime)+\"ms\"); } public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { test(); test2(); test3(); }} 结果： 反射操作泛型Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器Javac使用的，通过泛型确保数据的安全性和免去强制类型的转换问题，但是，一旦编译完成，所有和泛型有关的类型都会全部擦除掉 为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型，但是又和原始类型齐名的类型 ParameterizedType： 表示一种参数化类型， GenericArrayType： 表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable： 是各自类型变量的公共父接口 WildcardType： 代表一种通配符类型表达式 例子： package com.my.reflection;//通过反射获取泛型public class ClassLearn4 { public void test01(Map map, List list){ System.out.println(\"test01\"); } public Map test02(){ System.out.println(\"test02\"); return null; } public static void main(String[] args) throws NoSuchMethodException { //获取方法的参数类型 Method test01 = ClassLearn4.class.getMethod(\"test01\", Map.class, List.class); System.out.printf(test01+\"\\n\\n\"); Type[] genericParameterTypes = test01.getGenericParameterTypes(); System.out.printf(\"方法参数：\\n\"); for (Type genericParameterType : genericParameterTypes) { System.out.println(\"总的方法参数： \"+genericParameterType); System.out.println(\"具体的方法参数：\"); if(genericParameterType instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } System.out.println(); } } //获取方法的返回值类型 Method test02 = ClassLearn4.class.getMethod(\"test02\", null); Type genericReturnType = test02.getGenericReturnType(); System.out.println(\"总的返回值类型: \"+genericReturnType); if(genericReturnType instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments(); System.out.printf(\"\\n具体的返回值类型：\\n\"); for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } } }} 结果： 反射操作注解例子： package com.my.reflection;//通过反射获取注解public class ClassLearn5 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { Class studentClass = Class.forName(\"com.my.reflection.Student\"); //通过反射获取注解,但这样只能获取到Class外面的注解 Annotation[] annotations = studentClass.getAnnotations(); System.out.println(\"获取注解：\"); for (Annotation annotation : annotations) { System.out.println(annotation); } //获取注解的value的值 //先获取特定的注解 TableLearn tableLearnAnnotation = (TableLearn) studentClass.getAnnotation(TableLearn.class); //获取特定注解的value System.out.println(tableLearnAnnotation.value()); //获取类的变量的注解 Field name = studentClass.getDeclaredField(\"name\"); ColLearn nameAnnotation = name.getAnnotation(ColLearn.class); System.out.printf(\"\\n获取类的变量的注解:\\n\"); System.out.println(nameAnnotation); System.out.println(nameAnnotation.type()); System.out.println(nameAnnotation.columnName()); System.out.println(nameAnnotation.length()); }}@TableLearn(\"student\")class Student{ @ColLearn(columnName = \"id\",type = \"int\",length = 11) private int id; @ColLearn(columnName = \"age\",type = \"int\",length = 5) private int age; @ColLearn(columnName = \"name\",type = \"varchar\",length = 3) private String name; public Student() { } public Student(int id, int age, String name) { this.id = id; this.age = age; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Student{\" + \"id=\" + id + \", age=\" + age + \", name='\" + name + '\\'' + '}'; }}//表注解，值为表名@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface TableLearn{ String value(); //表名}//列注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface ColLearn{ String columnName(); //列名 String type(); //列的类型 int length(); //列的长度} 结果：","permalink":"https://wakie01.github.io/2021/03/05/1608/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"Java Lamda表达式","date":"2021/03/01","text":"Lamda表达式是JDK1.8以后的内容，是用于简化函数式接口（Function Interface）的 函数式接口：如果在一个接口中，它只有一个抽象方法，那它就是一个函数式接口 例子： 无参的 public class LamdaLearn { //2. 静态内部类 static class Say2 implements ISay { public void sayHello() { System.out.println(\"hello 2\"); } } public static void main(String[] args) { ISay say; say=new Say1(); say.sayHello(); say=new Say2(); say.sayHello(); //3. 局部内部类 class Say3 implements ISay { public void sayHello() { System.out.println(\"hello 3\"); } } say=new Say3(); say.sayHello(); //4.局部匿名类 say=new ISay() { public void sayHello() { System.out.println(\"hello 4\"); } }; say.sayHello(); //5.Lamda表达式 say= ()->{ System.out.println(\"hello 5\"); }; say.sayHello(); //6.Lamda表达式 ,方法只有一行代码 say=()->System.out.println(\"hello 6\"); say.sayHello(); }}//1. 实现类class Say1 implements ISay{ public void sayHello() { System.out.println(\"hello 1\"); }}interface ISay{ public void sayHello();} 简化的过程： 实现类 –> 静态内部类 –> 局部内部类 –> 局部匿名类 –> Lamda表达式 例子二： 有参数的 public class LamdaLearn { //2. 静态内部类 static class Say2 implements ISay { public void sayHello(int a,int b) { System.out.println(\"hello \"+a+b); } } public static void main(String[] args) { ISay say; say=new Say1(); say.sayHello(1,2); say=new Say2(); say.sayHello(3,4); //3. 局部内部类 class Say3 implements ISay { public void sayHello(int a,int b) { System.out.println(\"hello \"+a+b); } } say=new Say3(); say.sayHello(5,6); //4.局部匿名类 say=new ISay() { public void sayHello(int a,int b) { System.out.println(\"hello \"+a+b); } }; say.sayHello(7,8); //5.Lamda表达式 say= (int a,int b)->{ System.out.println(\"hello \"+a+b); }; say.sayHello(9,10); //6.Lamda表达式 ,方法只有一行代码 say=(int a,int b)->System.out.println(\"hello \"+a+b); say.sayHello(11,12); //7.Lamda表达式 ,省去参数类型 say=(a,b)->System.out.println(\"hello \"+a+b); say.sayHello(13,14); }}//1. 实现类class Say1 implements ISay{ public void sayHello(int a,int b) { System.out.println(\"hello \"+a+b); }}interface ISay{ public void sayHello(int a,int b);}","permalink":"https://wakie01.github.io/2021/03/01/1044/","photos":[]},{"tags":[],"title":"java对List进行排序","date":"2021/01/12","text":"简单的public class ListSortLearn { public static void main(String[] args) { List list=new ArrayList(); list.add(21.211); list.add(140.21); list.add(13.21); list.add(10.20); list.add(41.121); list.add(14.21); list.add(10.221); Collections.sort(list); System.out.println(list.toString()); }} 结果： 复杂的方法一：对要排序的类实现Comparable接口 public class ListSortLearn { public static void main(String[] args) { List menuRecordList=new ArrayList(); menuRecordList.add(new MenuRecord(1,10)); menuRecordList.add(new MenuRecord(2,4)); menuRecordList.add(new MenuRecord(3,75)); menuRecordList.add(new MenuRecord(4,31)); menuRecordList.add(new MenuRecord(5,8)); menuRecordList.add(new MenuRecord(6,10)); menuRecordList.add(new MenuRecord(7,170)); menuRecordList.add(new MenuRecord(8,210)); Collections.sort(menuRecordList); System.out.println(menuRecordList.toString()); }}class MenuRecord implements Comparable{ private int menuId; private int num; public MenuRecord() { } public MenuRecord(int menuId, int num) { this.menuId = menuId; this.num = num; } public int getMenuId() { return menuId; } public void setMenuId(int menuId) { this.menuId = menuId; } public int getNum() { return num; } public void setNum(int num) { this.num = num; } @Override public int compareTo(MenuRecord o) { return o.getNum()-this.num; } @Override public String toString() { return \"(\"+menuId+\",\"+num+\")\"; }} 结果： 方法二：传入自己实现的Comparable接口 public class Employee { public int id; public int importance; public List subordinates; @Override public String toString() { return \"Employee{\" + \"id=\" + id + \", importance=\" + importance + \", subordinates=\" + subordinates + '}'; } public static void main(String[] args) { List list=new ArrayList(); for(int i=0;i{ return o2.importance-o1.importance; //根据importance从大到小排序 }); //同上}","permalink":"https://wakie01.github.io/2021/01/12/null/","photos":[]},{"tags":[{"name":"Time","slug":"Time","permalink":"https://wakie01.github.io/tags/Time/"}],"title":"java获取当前时间的前n天","date":"2021/01/12","text":"public class DateLearn { public static void main(String[] args) { SimpleDateFormat dateFormat=new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); Date date=new Date(); System.out.println(\"当前时间: \"+dateFormat.format(date)); Calendar calendar=Calendar.getInstance(); calendar.setTime(date); //获取当前时间的后1个钟 calendar.add(Calendar.HOUR,1); date=calendar.getTime(); System.out.println(\"后1个钟: \"+dateFormat.format(date)); //获取当前时间的前7天 calendar.add(Calendar.DATE,-7); date=calendar.getTime(); System.out.println(\"前7天: \"+dateFormat.format(date)); //获取当前时间的前1个月 calendar.add(Calendar.MONTH,-1); date=calendar.getTime(); System.out.println(\"前1个月: \"+dateFormat.format(date)); }} 结果： 注意：这个calendar是连着来加减时间","permalink":"https://wakie01.github.io/2021/01/12/1118/","photos":[]},{"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://wakie01.github.io/tags/Mysql/"}],"title":"Mysql常用SQL语句","date":"2021/01/11","text":"这篇文章主要是想重温一下关于Mysql**增删改查**的SQL语句 在这里首先假设几个表： Menu( id,int(11) unsigned,primary key,auto increment; name,varchar(20),not null; quantity,int(10) unsigned,not null; price,double(10,2) unsigned,not null; description,varchar(100); image,varchar(50); typeId,int(10) unsigned,not null)Bill( id,int(11) unsigned,primary key,auto increment; deskId,int(11) unsigned,not null; orderTime,datetime; finish,bit(1),not null; userId,int(10) unsigned;)MenuBill( billId,int(11) unsigned,not null; menuId,int(11) unsigned,not null; quantity,int(11) unsigned,not null; finish,bit(1) not null; menuTime,datetime; userId,int(11)) 增INSERT语句INSERT语句有几种常用的用法： 简写 insert into Bill values(1,1,NOW(),0,1); 这样写要按顺序，一一对应 完整一点 insert into Bill(deskId,orderTime,finish) values(1,NOW(),0); 直接表明插入到哪里 插入多个 insert into Bill(deskId,orderTime,finish) values(1,NOW(),0),(2,NOW(),0),(3,NOW(),1); REPLACE语句 作用：当我们在插入一条数据时，如果该数据已存在，则会替换掉旧的数据，没有的话就直接插入 replace into Bill(id,deskId,finish) values(1,1,0); 注意：是通过主键来判断数据是否存在的 REPLACE语句也是可以插入多个的，与INSERT语句的一样 INSERT IGNORE语句 作用：与REPLACE语句相反，当我们在插入一条数据时，如果该数据已存在，则会跳过不插入，没有的话就直接插入 insert ignore into Bill(id,deskId,finish) values(1,1,0),(2,3,0); 也是通过主键来判断数据是否存在的 也是可以插入多个的，与INSERT语句的一样 INSERT SELECT语句 作用：将从A表查询到的数据插入到B表中，这样可以实现较快速的多个插入 insert into B(name,age,class) select(name,age,class) from A; 字段的类型对应上就行 删DELETE语句delete from bill; -- 删除bill表中的所有数据delete from bill where id=1; -- 删除对应的数据delete from bill order by orderTime limit 2; -- 删除以orderTime从小到大排序的前2条数据 TRUNCATE语句truncate table bill； -- 清空bill表数据 二者对比： 相同点：都可删除数据，都不会影响表结构 区别：delete不会影响自增，而truncate会 改UPDATE语句update menubill set finish=1,menuTime=NOW(),userId=1 where billId=1 and menuId=1; 用法： 当更新多个列时，用逗号隔开 若没有where子句，则表示更新表中的所有行 UPDATE JOIN语句查select语法： select [all | distinct]{* | table.* | [table.field1 [as alias1] [,table.field2 [as alias2]] [,...]]}from table_name [as table_alias] [left | right | inner join table_name2] -- 联合查询 [where ...] -- 指定结果需满足的条件 [group by ...] -- 指定结果按照哪几个字段来分组 [having ...] -- 过滤分组的记录必须满足的次要条件 [order by ...] -- 指定查询记录按一个或多个条件排序 [limit {[offset,] row_count | row_countOFFSET offset }] -- 指定查询的记录从哪条至哪条 ; 符号意思： [] -- 可选{} -- 必选| -- 或 普通查询select * from bill wehre orderTime>20210101010101; //查询全部字段select id,deskId,orderTime from bill wehre orderTime>20210101010101; //查询对应字段 在平常的开发中，都建议第二种写法 相似点： 在查询的列数相同的情况下，二者的速度是差不多的 区别： 当查询的列数不一样时，速度是不一样的，尤其是当查询的列存在索引时。而且，第二种是明显方便他人读懂程序，方便合作对接。还有，当表结构修改时，第二种写法也会对代码的影响小很多 四则运算查询四则运算指：加减乘除 select id,name,quantity,price,quantity * price as benefit from menu; 条件查询就是使用where关键字 where后面的条件可以用>、=、80order by studentResult desclimit 10; 去重查询这里用到了distinct关键字 -- 对查询结果进行去重select distinct billId,finish from `menubill`; 当distinct应用到多个字段的时候，其应用的范围是其后面的所有字段，而不只是紧挨着它的一个字段，而且distinct只能放到所有字段的前面 与distinct对反的就是all关键字，当然默认是all 系统变量查询select @@auto_increment_increment -- 查询自增步长 常见系统变量： @@auto_increment_increment -- 自增步长 子查询 对于子查询，它的查询顺序是由里及外，先执行里面的，再执行外面的 例子一： select studentNo,subjectNo,studentResult from resultwhere subjectNo=( select subjectNo from subject where subjectName='数据库结构-1')order by studentResult desc; 例子二： -- 子查询select distinct s.studentNo,studentName,studentResultfrom student sinner join result r on r.studentNo=s.studentNowhere studentResult>=80 and subjectNo=( select subjectNo from subject where subjectName='高等数学-2');-- 子查询select studentNo,studentName from studentwhere studentNo in ( select studentNo from result where studentResult>=80 and subjectNo=( select subjectNo from subject where subjectName='高等数学-2' ));-- 连表查询select distinct s.studentNo,studentName,studentResultfrom student sinner join result r on s.studentNo=r.studentNoinner join subject sub on sub.subjectNo=result.subjectNowhere subjectName='高等数学-2' and studentResult>=80; 一般来说，JOIN连表查询比子查询快。 函数查询具体函数可到mysql官网上看 select version(); -- 查询mysql版本号 常见函数-- 系统select version(); -- 查询mysql版本号select user() -- 获取当前用户-- 数学函数select celling(9.4) -- 向上取整select floor(9.4) -- 向下取整select rand() -- 返回一个0~1之间的随机数select sign(10) -- 判断一个数的符号，0返回0，负数返回-1，正数返回1-- 字符串函数select char_length('hello world') -- 字符串长度select concat('hello','world','!!!') -- 拼接字符串select lower('Hello World') -- 转小写select upper('hello world') -- 转大写-- 时间日期函数select current_date() -- 获取当前日期select now() -- 获取当前时间select localtime() -- 获取本地时间select year(now()) -- 获取当前时间的年select month(now()) -- 获取当前时间的月select day(now()) -- 获取当前时间的日select hour(now()) -- 获取当前时间的时select minute(now()) -- 获取当前时间的分select second(now()) -- 获取当前时间的秒-- 加密函数MD5('123456') -- 将123456加密成MD5 聚合函数count()函数 -- 获取表中数据的个数select count(bornDate) from student;select count(*) from student;select count(1) from student; 区别： count(字段) ，会忽略所有的null值 count(*) ，count(1)，都不会忽略null值，都差不多，其本质都在计算行数 sum()函数 总和函数 select sum(studentResult) as '总和' from student; avg()函数 平均值函数 select avg(studentResult) as '平均分' from student; max()函数 最大值函数 select max(studentResult) as '最高分' from student; min()函数 最小值函数 select min(studentResult) as '最低分' from student; 分组和过滤分组：group by…… 过滤：having …… 注意：where不能放在group by 后，对于分组的过滤只能用having 例子： /*查询各个科目的最低分，最高分，平均分，并且平均分要大于80涉及到表：result,subject关联点：subjectNo分组点：subjectNo过滤点：studentResult*/select subjectName,min(studentResult) as '最低分',avg(studentResult) as '最高分',avg(studentResult) as '平均分'from result rinner join subject sub on r.subjectNo=sub.subjectNogroup by subjectNohaving '平均分'>80; 条件字段WHERE常用条件有： =、>、>=、","permalink":"https://wakie01.github.io/2021/01/11/1657/","photos":[]},{"tags":[{"name":"AI","slug":"AI","permalink":"https://wakie01.github.io/tags/AI/"}],"title":"Learning Hierarchy-Aware Knowledge Graph Embeddings for Link Prediction论文学习笔记","date":"2021/01/04","text":"中文名：面向链路预测的学习层次感知知识图嵌入 1.干什么的提出了Hierarchy-Aware Knowledge Graph Embeddings（HAKE模型），完善对知识图谱的建模 2.完善了什么在这之前，TransE与RotatE也进行了对知识图谱的建模，不过都有不足之处 TransE：可以建模互逆关系与复合关系，却难以建模对称关系 RotatE：可以建模互逆关系与复合关系，还有对称关系，却难以建模在知识图谱中普遍存在的语义分层现象 所以，这篇论文解决的就是：建模在知识图谱中普遍存在的语义分层现象 3.怎么完善HAKE模型通过**极坐标系**表示语义层级的树型结构，它将所有实体都嵌入、映射到同一个极坐标系中，其中 模长：用于表示分属不同层级的实体 角度：用于表示同一层级的实体 在论文中，这个模长与角度有更专业的术语，分别是模量（Modules）与相位（Phase) 下图中的p、m下标指的就是Modules与Phase的缩写 4.评价方法通过链接预测任务来对模型的有效性进行评价 就是对于给定的三元组，先去掉他们的头实体或尾实体，然后生成测试三元组，然后再拿这些测试三元组进行嵌入补全测试，然后得到一个预测的完整三元组，然后再拿这个预测的三元组与真实的三元组进行比较，得到一个分数值，最后对该分数值进行降序排序。 还有，这个分数值采用MRR(Mean Reciprocal Rank)和H@N(Hits at N)作为评价指标，MRR为预测结果平均排名的指标，H@N为预测结果排在前N名中的比例，总之，越好的预测结果，MRR值与H@N值也越高 补漏知识图谱知识图谱，是一种揭示实体之间关系的语义网络 信息与知识的关系，就好比这个图，信息是零散的，对信息建立联系就变成了知识 所以，知识图谱是由一条条知识组成，这一条条的知识有个专业术语：事实（Fact） 事实（Fact）一般以三元组（Triple）的形式表示：（） 又比如下面这个图，就是一个三元组，表示DA VINCI painted MONA LISA。 参考： 知乎-什么是知识图谱? AAAI 2020 | 中科大：可建模语义分层的知识图谱补全方法 建模建模就是将事物抽象化 即：对事物进行概括化、下定义（我的理解） 百度百科： 建模，就是建立模型，就是为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述。建立系统模型的过程，又称模型化。建模是研究系统的重要手段和前提。凡是用模型描述系统的因果关系或相互关系的过程都属于建模。 计算机建模，指借助于计算机建立数学模型、数值求解、定量研究某些现象或过程的研究方法。 语义分层语义分层，英文：Semantic Hierarchies，语义层次，英文：semantic hierarchy，两者都差不多 百度百科： 语义层次模型是由柯林斯和奎利恩(Collins & Quillian, 1969)提出来的，是语义记忆研究领域中最著名的理论。 这个模型的基本思想是，语义记忆是由概念之间的相互联系形成的一个巨大网络，而这个网络是有一定层次结构的，知识的提取就是这个层次网络作用的结果。 在语义记忆中，概念被分层次地组织成有逻辑性的种属关系。 例如，“金丝鸟”的上位概念是“鸟”，“鸟”的上位概念是“动物”。每一类事物的特征总是储存在对应于该类别的层次上。 例如，“有翅膀”只储存在“鸟”这一层次，不会储存在“金丝鸟”等下位概念的层次，尽管“金丝鸟”也是有翅膀的。这样的安排可以体现“认知经济性原则”——各种特征或事实总是储存在尽可能最高的层次上，下属层次可以“共享”这些特征或事实而不必另外占用储存空间。 这时，我们会发现语义分层现象可以抽象为树型（Tree）结构： 处于最高语义层级的实体对应着树的根节点 拥有更高的语义层级的实体更加接近根节点 语义层级更低的实体更加接近叶子节点 处于相同语义层级的实体到根节点的距离相同 比如：","permalink":"https://wakie01.github.io/2021/01/04/1133/","photos":[]},{"tags":[],"title":"ARP协议","date":"2021/01/02","text":"概述ARP协议，Address Resolution Protocol，地址解析协议，用于实现从IP地址到MAC地址的映射 OSI七层模型：物、联、网、输、会、试、用 ARP解析过程ARP的解析过程可分为静态映射与动态映射 每个主机都有一张ARP表，主机A与主机B进行通信时，主机A知道主机B的IP地址，但不知道主机B的MAC地址，怎么办呢？ 这时主机A会先检索本地的ARP表，看看有无对应的MAC地址，有的话就是映射成功，这个过程叫静态映射；没有的话，就进行动态映射 静态映射在网络层到数据链路层的打包过程中，需要将IP地址映射成MAC地址 主机本地都有一张ARP表，用来存储IP地址与MAC地址的映射关系，因为MAC地址可能会变，所以ARP表每隔一段时间就要更新一次，就好像缓存那样。 动态映射当主机A本地的ARP表没有对应IP的MAC地址时，主机A会在局域网中广播一个ARP请求报文 这个ARP请求报文有以下内容： 发送方的IP地址 发送方的MAC地址 接收方的IP地址 其它信息 局域网中的每个主机收到这个ARP请求报文之后，都会查询以下本地的ARP表，看看有无对应的MAC地址，有的话就单播返回给主机A一个ARP响应报文 这个ARP响应报文有以下内容： 发送方的IP地址 发送方的MAC地址 接收方的IP地址 接收方的MAC地址 其它信息 主机A收到之后就会更新本地的ARP表 参考：1.csguo的图解ARP协议（一）2.沉默的鹏先生的ARP学习总结3.小鹏_加油的OSI七层模型详解","permalink":"https://wakie01.github.io/2021/01/02/null/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"Java的Enum使用","date":"2020/12/27","text":"枚举枚举类型有以下特性： 不可变 不相同 传统定义枚举public class DayDemo { public static final int MONDAY =1; public static final int TUESDAY=2; public static final int WEDNESDAY=3; public static final int THURSDAY=4; public static final int FRIDAY=5; public static final int SATURDAY=6; public static final int SUNDAY=7;} 问题 不同的枚举变量可能会手误弄成相同，而且相同之后又不容易被发现 Enum类Enum类是Java 5的新增特性， 例子 public enum Day { //枚举变量，一般用大写表示 //枚举变量间用逗号隔开，最后才用分号 //枚举变量也有类似构造函数之类的 MONDAY(1,\"星期一\"), TUESDAY(2,\"星期二\"), WEDNESDAY(3,\"星期三\"), THURSDAY(4,\"星期四\"), FRIDAY(5,\"星期五\"), SATURDAY(6,\"星期六\"), //有参数的构造函数 SUNDAY, //无参数的构造函数 ; //描述 枚举变量 的 具体变量 private int dayNum; private String desc; //枚举变量的构造函数，无参数 Day(){ } //枚举变量的构造函数，全参数 Day(int dayNum,String desc){ this.dayNum=dayNum; this.desc=desc; } //GET函数 public String getDesc(){ return desc; } public int getDayNum(){ return dayNum; }}public class Main { public static void main(String[] args) { Day day=Day.MONDAY; System.out.println(day); //输出MONDAY System.out.println(day.getDesc()); //输出星期一 }} 注意： 枚举变量的名字是不可以相同的，但枚举变量里的变量值又是可以相同的","permalink":"https://wakie01.github.io/2020/12/27/1030/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"java的static使用","date":"2020/12/26","text":"概述static是静态修饰符，所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间 用static修饰的成员可以通过类名加**·**进行直接访问 static的使用主要有3种： static变量 static方法 static代码块 static变量static变量，又叫静态变量，类的所有实例共享同一个static变量 一个类中可有多个static变量 public修饰 可在自己类中的任何地方直接引用（不需通过类名） 可在其它类中通过类名直接引用 protected修饰 可在自己类中的任何地方直接引用（不需通过类名） 可在同一个package下的其他类中通过类名直接引用 可被子类通过类名直接引用 private修饰 只可在自己类中的任何地方直接引用（不需通过类名） 不能在其他类中通过类名来直接引用 与final连用 表示变量一旦赋值，就不可修改，还是可以通过类名直接引用 static方法static方法，又叫静态方法，一个类中可有多个static方法 类的所有实例共享同一个static方法，因此静态方法中 不能用this、super关键字， 不能直接访问所属类的实例变量和实例方法 只能访问所属类的静态成员变量和成员方法 同样，方法前可被public、protected、private修饰，用法同static变量 与final使用 表示方法不可覆盖，还是可以通过类名直接使用 static代码块static代码块，又叫静态代码块，在类中独立于类成员的static语句块 可以有多个，位置可以随便放，JVM加载类时会按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次 同样，在静态代码块中 不能用this、super关键字， 不能直接访问所属类的实例变量和实例方法 只能访问所属类的静态成员变量和成员方法 使用 public class Hello{ static{ //static 代码块 }}","permalink":"https://wakie01.github.io/2020/12/26/1741/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"Java多线程学习","date":"2020/11/18","text":"进程与线程进程： ​ 每个进程都有独立的代码的数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1~n个线程。 ​ 多进程：指OS能同时运行多个任务（程序） 进程是资源分配的最小单位 线程： ​ 同一类线程共享代码和数据空间，每个线程都有独立的运行栈和程序计数器（PC），线程切换开销小。 ​ 多线程：指在同一个程序中有多个顺序流在执行 线程是CPU调度的最小单位 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止 值得注意的是： 线程是独立的执行路径 在程序运行时，即使自己没有创建线程，后台也会有多个线程，如main()主线程，垃圾回收线程（gc线程） 在一个进程中，若开辟了多个线程，线程的运行由调度器安排调度，调度器是与OS紧密相关的，先后顺序不能人为干预 对同一份资源操作时，会存在资源抢夺的问题，so需要加入并发控制 线程会带来额外的开销，如cpu调度时间，并发控制开销 每个线程在自己的工作内存中交互，内存控制不当会造成数据不一致 常见线程名词 主线程： JVM调用程序Main()所产生的线程 当前线程： 当前运行的线程，可通过Thread.currentThread()获取 守护线程（Daemon）： 也叫后台线程，指为其他线程提供服务的线程，JVM的垃圾回收线程就是一个后台线程 前台线程： 指接受后台线程服务的线程 对象锁： 可以理解为对象的钥匙，一个对象只有一把对象锁。 当一个对象中有同步方法、同步块时，当线程调用此对象并进入该同步区域时，必须要先获得对象锁，如果此对象的对象锁被其它线程占用，则会进入阻塞队列，等待此对象锁的释放。 注意，线程执行完同步方法、同步块后，就会马上把对象锁还给该对象。 这样就保证了同步方法、同步块每时每刻都只能有一个线程在执行。 方法锁： 方法锁也是一种对象锁 类锁： 可以理解为类的钥匙，一个类只有一把类锁 当一个类中有同步静态的东西时（包括变量、方法、块），当线程调用此类中的同步静态东西时，必须要先获得类锁，类似于对象锁。 类锁保证了类中的同步静态东西每时每刻都只能有一个线程在执行 JAVA实现多线程Java实现多线程，常用的有两种方法： 继承Thread类 实现Runnable接口 实现Callable接口 两者对比，第二种方法更常用 继承Thread类使用： ​ 新建一个类，继承java.lang.Thread类，重写run()方法 ​ 执行时调用线程类的start()方法 例子： public class Thread1 extends Thread { private String name; public Thread1(String name) { this.name = name; } @Override public void run() { for(int i=0;i","permalink":"https://wakie01.github.io/2020/11/18/1130/","photos":[]},{"tags":[{"name":"java","slug":"java","permalink":"https://wakie01.github.io/tags/java/"}],"title":"java的HashMap","date":"2020/11/13","text":"java HashMap的查询时间复杂度为O(1)，why？ 首先得说一下HashMap的put()方法 然后说一下HashMap的containsKey(key)方法 接下来的get(key)方法也是类似的。","permalink":"https://wakie01.github.io/2020/11/13/1017/","photos":[]},{"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://wakie01.github.io/tags/Nginx/"},{"name":"代理","slug":"代理","permalink":"https://wakie01.github.io/tags/%E4%BB%A3%E7%90%86/"}],"title":"Nginx学习","date":"2020/11/07","text":"Nginx介绍引言 问题：双十一时会有大量用户访问淘宝，一个服务器肯定不行，需要多个服务器，那用户该访问哪一个服务器呢？ 这就用到Nginx了， 客户端统一访问Nginx的服务器，然后由Nginx来做一个负载均衡的策略，根据一些算法来决定客户端的请求发给哪一个服务器，若是请求静态资源的话，还可以直接让Nginx的服务器发送给客户端。 此时这个Nginx的服务器，也叫反向代理服务器 介绍Nginx是俄罗斯人写的！！厉害厉害 特点： 稳定性极强 占用内存小，并发能力强 代理正向代理 正向代理服务时由客户端设立 客户端知道代理服务器和目标服务器是谁 有助于客户端突破访问权限，提高访问速度，对目标服务器隐藏客户端的ip地址 典型应用：SSR 反向代理 反向代理服务器是配置在服务端 客户端不知道访问的是哪一台服务器 有助于负载均衡，并且可以隐藏服务器真正的ip地址 典型应用：Nginx Nginx安装安装Docker安装非Docker安装在Ubuntu中，安装Nginx也很简单 # 切换到root用户$ sudo -i# 安装nginx$ apt-get install nginx# 验证$ nginx -v Nginx配置文件 Nginx的核心配置文件是nginx.conf user www-data;worker_processes auto;pid /run/nginx.pid;include /etc/nginx/modules-enabled/*.conf;# 以上是全局块# worker_processes的数值越大，Nginx的并发能力越强# pid：nginx运行的一个标识# include：引入该目录下的全部.conf文件配置# 有的还会有error_log /var/log/nginx/error.log; 指nginx错误日志的存放位置events { worker_connections 768; # multi_accept on;}# 以上是events块# worker_connections值越大，nginx并发能力越强http { include /etc/nginx/mime.types; default_type application/octet-stream; # Logging Settings access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; server { listen 80; server_name localhost; location / { root /home/Documents/nginx_html; index index.html index.htm; } # location块 # root：将接收到的请求根据/home/Documents/nginx_html去查找静态资源 # index：默认去上述的路径中找index.html或index.htm } # server块 # listen：代表Nginx监听的端口号 # server_name：代表Nginx接收请求的ip include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;} # Http块# include代表引入一个外部的文件 ->mime.type中放着大量的媒体类型# include /etc/nginx/conf.d/*.conf; ->引入conf.d目录下的以.conf结尾的配置文件 修改了Nginx的配置文件后，需重启一下Nginx # Ubuntu系统$ service nginx stop$ service nginx start Nginx常用配置反向代理配置server{ listen 80; server_name localhost; location / { proxy_pass http://192.168.199.109:8080/; proxy_send_timeout 120; # nginx发送数据到服务器的超时时间，默认60s proxy_read_timeout 120; # nginx接收服务器的数据的超时时间，默认60s }}# 当客户端访问Nginx服务器时，会映射到http://192.168.199.109:8080/ 今天发现服务器上的网页，有个请求请求了1分钟，不多不少，然后报404错误；然后在本地运行的时候，那个请求请求了1分半后，200，并返回了数据。 弄了很久，才突然意识到是nginx的代理超时时间配置的问题 location路径映射配置# 1. = 匹配location = / { # 精准匹配，主机名后面不能带任何的字符串} # 2. 通用匹配location /xxx { # 匹配所有以/xxx开头的路径 } # 3. 正则匹配location ~ /xxx { # 匹配所有以/xxx开头的路径} # 4. 匹配开头路径location ^~ /images/ { # 匹配所有以/images开头的路径} # 5. 匹配结尾路径location ~* \\.(gif|jpg|png)$ { # 匹配以gif或jpg或png为结尾的路径} 优先级关系： （location =） > （location /xxx/yyy/zzz） > （location ^） > （location ~，*） > （location /起始路径）>（location / ） 负载均衡策略 Nginx默认提供了三种负载均衡策略 轮询：将客户端发起的请求，平均地分配给每一台服务器 配置 http{ ... upstream 名字{ # 自己声明的变量一般不要用下划线，用下划线的一般是关键字 server ip:port; server ip:port; ... } server{ listen 80; server_name localhost; location / { proxy_pass http://upstream的名字/; } }} 比如： http{ ... upstream my-server{ # 自己声明的变量一般不要用下划线，用下划线的一般是关键字 server 192.168.199.109:8080; server 192.168.199.109:8081; } server{ listen 80; server_name localhost; location / { proxy_pass http://my-server/; } }} 权重：会将客户端的请求，根据服务器的权重值来分配 配置 http{ ... upstream 名字{ # 自己声明的变量一般不要用下划线，用下划线的一般是关键字 server ip:port weight=权重值; server ip:port weight=权重值; ... } server{ listen 80; server_name localhost; location / { proxy_pass http://upstream的名字/; } }} 比如： http{ ... upstream my-server{ # 自己声明的变量一般不要用下划线，用下划线的一般是关键字 server 192.168.199.109:8080 weight=10; server 192.168.199.109:8081 weight=2; } server{ listen 80; server_name localhost; location / { proxy_pass http://my-server/; } }} ip_hash：基于发起请求的客户端的ip地址不同，始终将请求发送到指定的服务器上 配置 http{ ... upstream 名字{ # 自己声明的变量一般不要用下划线，用下划线的一般是关键字 ip_hash; server ip:port; server ip:port; ... } server{ listen 80; server_name localhost; location / { proxy_pass http://upstream的名字/; } }} 比如： http{ ... upstream my-server{ # 自己声明的变量一般不要用下划线，用下划线的一般是关键字 ip_hash; server 192.168.199.109:8080; server 192.168.199.109:8081; } server{ listen 80; server_name localhost; location / { proxy_pass http://my-server/; } }} 动静分离配置对于这样的一个环境 Nginx并发能力计算： $$Nginx最终的并发能力= worker_processes * worker_connections /4|2$$ 其中，除以4是请求动态资源时，除以2是请求静态资源时 这样，通过动静分离，有助于提升Nginx的并发能力，从而更快的给用户响应 动态资源代理配置： location / { proxy_pass 路径;} 也就是反向代理配置 静态资源代理配置： # 访问 / 时的静态资源 （局部）location / { root 静态资源路径; index 默认访问路径下的什么资源; autoindex on; # 代表展示静态资源的全部内容，并以列表的形式展开 （可要可不要） expires 缓存时间; # 启用缓存}# 访问Nginx服务器时的静态资源 （全局）server{ root 静态资源路径; index 默认访问路径下的什么资源; autoindex on; # 代表展示静态资源的全部内容，并以列表的形式展开 （可要可不要） expires 缓存时间; # 启用缓存} 比如： server{ root /home/lab1204/Documents/nginx_html; index index.html index.htm; expires 24h; # 启用缓存,有效期为24小时}","permalink":"https://wakie01.github.io/2020/11/07/1145/","photos":[]},{"tags":[],"title":"git fetch不了","date":"2020/10/12","text":"fatal: early EOFfatal: the remote end hung up unexpectedlyfatal: index-pack failederror: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 很尬尴，弄了半天才发现是网络的问题。笔记本自动连了打印机的WiFi","permalink":"https://wakie01.github.io/2020/10/12/null/","photos":[]},{"tags":[{"name":"前端","slug":"前端","permalink":"https://wakie01.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"跨域","slug":"跨域","permalink":"https://wakie01.github.io/tags/%E8%B7%A8%E5%9F%9F/"}],"title":"前端跨域问题","date":"2020/10/04","text":"记得在弄毕业设计时，遇到一个问题，至今我都印象深刻： 当时我懵了了好久，what？？’Access-Control-Allow-Origin’ header是什么鬼？CORS policy又是什么鬼？ 经过几天百度，才知道这是跨域问题，是前后端分离后一定要处理的问题 Why跨域跨域是因为浏览器的同源策略 所以，跨域在某种程度上就算跨源 同源策略同源策略是一个安全策略，它用于限制一个源的资源与另一个源的资源进行交互 同源指两个url的协议、端口、主机（域名）相同，比如： 这就是为什么我那个前后端分离的项目出现不同源问题 为什么需要同源策略呢？ 预防CSRF攻击 CSRF，Cross-site request forgery，跨站请求伪造：攻击者盗用了你的身份，以你的名义发送恶意请求 预防非同源的Dom查询，比如： //HTML //JS//由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Domconst iframe=window.frames['yinhang']const node=iframe.document.getElementById('你输入账号密码的Input')console.log(\"密码\",node.value) 我现在才知道，为什么当时我修改不了iframe里面的css样式 跨源访问跨源访问常见的有几种方法 CORS 服务器代理 CORSCORS，Cross-Origin Resource Sharing，跨源资源共享，也称跨域资源共享 该机制使用附加的HTTP头来告诉浏览器，准许运行在一个源上的Web应用访问位于另一不同源选定的资源 CORS需要浏览器和服务器同时支持。目前，绝绝绝大部分浏览器都支持CORS，所以实现CORS的关键是服务器 想当年，我毕设就是通过配置CORS来解决这个朦朦胧胧的跨域问题 对Spring boot后端，我的解决方法： 1、新建配置类：MyWebAppConfigurer.java，比如： 2、添加下面代码： @Configurationpublic class MyWebAppConfigurer implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\") //允许跨域访问接口 '/**'表示全部接口 .allowedOrigins(\"http://localhost:8100\",\"http://localhost\") //允许哪些源可跨域访问 .allowedMethods(\"GET\",\"POST\",\"HEAD\",\"DELETE\",\"OPTIONS\") //允许跨域的请求方法 .allowCredentials(true); //允许cookies跨域 }} 服务器代理这个不同的前端框架往往会不一样，不过思想都是一样的，就是将前端的源转成与后端同源。 参考：1.MDN-浏览器的同源策略2.写Bug兄弟的一篇NB博文3.hyddd关于CSRF的博文4.MDN-跨源资源共享(CORS)5.阮一峰博文-跨域资源共享 CORS 详解","permalink":"https://wakie01.github.io/2020/10/04/1534/","photos":[]},{"tags":[{"name":"前端","slug":"前端","permalink":"https://wakie01.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"title":"html+css+js实现验证码","date":"2020/10/03","text":"我这个验证码的实现主要用的是canvas标签，然后获取canvas的CanvasRenderingContext2D，然后用它来手动绘画 代码 var canvasWidth = 400; //验证码宽度 （与px的对不上，可能是单位问题） var canvasHeight = 155; //验证码高度 var codeLength = 4; //验证码长度 var backgroundColorMin = 200; //验证码图片背景色最小值 var backgroundColorMax = 220; //验证码图片背景色最大值 var fontColorMin = 50; //数字颜色最小值 var fontColorMax = 160; //数字颜色最大值 var fontSizeMin = 45; // 字体最小值 var fontSizeMax = 55; // 字体最大值 var degMin = -30; //旋转最小角度 var degMax = 30; //旋转最大角度 var lineColorMin = 100; //干扰线颜色最小值 var lineColorMax = 200; //干扰线颜色最大值 var lineNum = 10; //干扰线数量 var dotColorMin = 0; //干扰点颜色最小值 var dotColorMax = 255; //干扰点颜色最大值 var dotNum = 30; //干扰点数量 var code=\"\"; window.onload = drawPic; function drawPic() { document.getElementById(\"codeInput\").value=\"\"; var verticalCode = document.getElementById(\"verticalCode\"); var content2d = verticalCode.getContext(\"2d\"); //获得CanvasRenderingContext2D 实例 content2d.fillStyle = randomColor(backgroundColorMin, backgroundColorMax); //设置背景颜色 content2d.fillRect(0, 0, canvasWidth, canvasHeight); //根据当前的填充样式，填充矩形 for (var i = 0; i < codeLength; i++) { drawText(content2d, i); } drawLine(content2d); drawDot(content2d); } //生成随机颜色 function randomColor(min, max) { var r = Math.floor(Math.random() * (max - min) + min); var g = Math.floor(Math.random() * (max - min) + min); var b = Math.floor(Math.random() * (max - min) + min); return 'rgb(' + r + ',' + g + ',' + b + ')'; } //绘制随机数字 function drawText(content2d, i) { content2d.fillStyle = randomColor(fontColorMin, fontColorMax); //随机生成字体颜色 content2d.font = Math.floor(Math.random() * (fontSizeMax - fontSizeMin) + fontSizeMin) + 'px SimHei'; //设置字体 var x = (i + 1) * (canvasWidth / (codeLength+3)); var y = Math.floor(Math.random() * (canvasHeight - 5 - fontSizeMax) + fontSizeMax); var deg = Math.floor(Math.random() * (degMax - degMin) + degMin); //随机角度 var txt = Math.floor(Math.random() * 9).toString(); //随机数 if(i==0){ code=\"\"; } code+=txt; // 修改坐标原点和旋转角度 content2d.translate(x, y); //移动坐标原点 content2d.rotate(deg * Math.PI / 180); //旋转 content2d.fillText(txt, 0, 0); //恢复坐标原点和旋转角度 content2d.rotate(-deg * Math.PI / 180); content2d.translate(-x, -y) } // 绘制干扰线 function drawLine(content2d) { for (var i = 0; i < lineNum; i++) { content2d.strokeStyle = randomColor(lineColorMin, lineColorMax); //设置画笔的颜色 content2d.beginPath(); //清空子路径列表，并开始一个新路径 var moveToX = Math.floor(Math.random() * canvasWidth); var moveToY = Math.floor(Math.random() * canvasHeight); content2d.moveTo(moveToX, moveToY); //移动路径的起点 var lineToX = Math.floor(Math.random() * canvasWidth); var lineToY = Math.floor(Math.random() * canvasHeight); content2d.lineTo(lineToX, lineToY); //使用直线连接路径的终点到x，y坐标，注意：并不会真正地绘制 content2d.stroke(); //绘制当前或已经存在的路径的方法 } } // 绘制干扰点 function drawDot(content2d) { for (var i = 0; i < dotNum; i++) { content2d.fillStyle = randomColor(dotColorMin, dotColorMax); content2d.beginPath(); var x = Math.floor(Math.random() * canvasWidth); //圆心的 x 轴坐标。 var y = Math.floor(Math.random() * canvasHeight); //圆心的 y 轴坐标。 var radius = 1; //圆弧的半径 var startAngle = 0; //圆弧的起始点 var endAngle = 2 * Math.PI; //圆弧的终点 content2d.arc(x, y, radius, startAngle, endAngle); //绘制圆弧路径 content2d.fill(); //根据当前的填充样式，填充当前或已存在的路径 } } function vertify(){ var codeInput=document.getElementById(\"codeInput\").value; if(codeInput==code){ alert(\"验证正确\"); }else{ alert(\"验证错误\"); } document.getElementById(\"codeInput\").value=\"\"; } 运行结果： 站在巨人的肩膀上 参考：1.MDN-canvas标签2.MDN-CanvasRenderingContext2D API","permalink":"https://wakie01.github.io/2020/10/03/1302/","photos":[]},{"tags":[{"name":"前端","slug":"前端","permalink":"https://wakie01.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Typescript","slug":"Typescript","permalink":"https://wakie01.github.io/tags/Typescript/"}],"title":"Typescript Map使用","date":"2020/09/30","text":"Typescript中的Map类型类似于Java中的Hashset 今天认识到了关于Typescript的Map的一种不知道叫什么名字的用法，直接来吧 //随便取一段代码const { data: result } = await this.$http.post('/wjm/cips', qs.stringify(this.queryInfo)).catch((err) => { alert(err)})console.log(\"result: \",result) 输出result变量： 这个const { data: result } 是什么意思呢？不急，只要将它替换成const result然后打印一下，就知道了 替换后输出result变量： 这个data:相当于一个选择的功能","permalink":"https://wakie01.github.io/2020/09/30/1037/","photos":[]},{"tags":[{"name":"前端","slug":"前端","permalink":"https://wakie01.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"title":"前端export default跟export的区别","date":"2020/09/28","text":"之前在弄Ionic4时，还有现在在弄的Vue中，都多次接触到export default与export的字样，如： export：输出、出口 望文生义，这两个都是用来输出常量、函数、模块等 区别 export default export import 导入方式 导入时不用加{} 导入时要加{} 一个文件or模块可有数量","permalink":"https://wakie01.github.io/2020/09/28/1507/","photos":[]},{"tags":[{"name":"ML","slug":"ML","permalink":"https://wakie01.github.io/tags/ML/"}],"title":"机器学习基础","date":"2020/09/19","text":"在我的理解中，机器学习就是用数据训练出一个模型，然后用这个模型去预测新的数据。 基本术语 模型（Model）： 计算机层面的认知 学习算法（Learning Algorithm）： 计算机从数据中产生模型的算法 示例（Instance）： 对象的一条记录 样本（Sample）： 同示例 属性（Attribute）： 对象在某方面的表现或性质 特征（Feature）： 同属性 属性值（Attribute Value）： 属性值 属性空间（Attribute Space）： 属性张成的空间，n个属性就是n维空间 样本空间（Sample Space）： 同属性空间 输入空间： 同属性空间 特征向量（Feature Vector）： 一个样本在属性空间中对应的坐标向量，因此也把一个样本称作特征向量 维数（Dimensionality）： 对象的属性数量 学习（Learning）： 从数据中学得模型的过程 训练（Training）： 同学习 训练数据（Training Data）： 训练过程中使用的数据 训练样本（Training Sample）： 训练数据中的一条数据 训练示例（Training Instance）： 同训练样本 训练例： 同训练示例 训练集（Training Set）： 训练样本组成的集合，即训练数据 假设（Hypothesis）： 模型对应关于数据的某种可能的规律，即有可能的算法 真相、真实（Ground-Truth）： 模型对应关于数据的真正的规律，即正确的算法 学习器（Learner）： 模型的另一种叫法，把学习算法在给定数据和参数空间的实例 预测（Prediction）： 判断一个样本的标记 标记（Label）： 示例结果的信息 样例（Example）： 拥有标记信息的示例 若将标记看作对象本身的一部分，则**样例有时也称为样本** 标记空间（Label Space）： 向量的集合，其中这个向量是((属性值一,属性值二,……,属性值n),标记) 输出空间： 同标记空间 回归（Regression）： 预测的值是个连续值，即标记是个连续值 分类（Classification）： 预测的值是个离散值，即标记是个离散值 二分类（Binary Classification）： 分类的值只有两个，其中一个叫正类（Positive Class），另一个叫反类（Negative Class） 多分类（Multi-class Classification）： 分类的值不止两个 测试（Testing）： 学得模型后，使用其进行预测的过程 学得模型 ：我理解是学习完成后的模型为什么不叫 学习模型 ？因为我感觉这是还在学习的意思，还没学完 测试样本（Testing Sample）： 测试时使用的样本 测试示例（Testing Instance）： 同测试样本 测试例： 同测试样本 聚类（Clustering）： 把训练集中的对象分为若干组 簇（Cluster）： 聚类后的每一组叫簇 监督学习（Supervised Learning）： 训练数据中有标记的学习，典型代表有回归和分类 有导师学习： 同监督学习 无监督学习（Unsupervised Learning）： 训练数据中没有标记的学习，典型代表有聚类 泛化（Generalization）： 学得模型适应新样本的能力 分布（Distribution）： 样本空间的全体样本服从的一种规律 独立同分布（Independent And Identically Distributed，简称: i.i.d.）： 获得的每个样本都是独立地从这个分布上采样获得的 验证集（Validation Set）： 指模型评估与选择中用于评估测试的数据集 测试集： 其实测试集包含验证集，不过为了区分，现在都默认指学得模型在实际使用中遇到的数据集 机械学习： 仅把训练集中的样本记住 死记硬背式学习： 同机械学习 版本空间（Version Space）： 与训练集对应上的假设的集合，即假设集合 归纳偏好（Inductive Bias）： 机器学习算法在学习过程中对某种类型假设的偏好，简称偏好 “没有免费的午餐”定理（No Free Lunch Theorem）： 在所有”问题”出现的机会相同、或所有问题同等重要的前提下，学习算法的期望性能都是相同的，简称NFL定理 参考：1.《机器学习》（西瓜书） 周志华","permalink":"https://wakie01.github.io/2020/09/19/1957/","photos":[]},{"tags":[{"name":"Cache","slug":"Cache","permalink":"https://wakie01.github.io/tags/Cache/"}],"title":"前端常用缓存技术","date":"2020/09/10","text":"之前在弄记住密码时接触到部分前端缓存的皮毛，大为震惊！！没想到还有这东西！！当时就想一定要记录一下 前端常用的缓存技术有，如下图所示：(或许我这个称呼不太对) Local Storage Session Storage Cookies 至于上图中的IndexedDB、Web SQL、Cache Storage、Application Cache，我还不太熟悉 Local Storage在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小 测试localStorage、sessionStorage在浏览器中支持的存储大小 localStorage的优势 localStorage拓展了cookie的4K限制 将第一次请求的数据直接存储到本地，节约带宽 localStorage的局限 浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性 目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换 localStorage在浏览器的隐私模式下面是不可读取的 localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 localStorage不能被爬虫抓取到 使用测试可用性 由于部分浏览器在某些情况下会禁用Local Storage，如私有浏览模式、用户手动禁用，所以在使用前最好先判断一下，测试一下Local Storage可用性 //测试函数function storageAvailable(type) { var storage; try { storage = window[type]; var x = '__storage_test__'; storage.setItem(x, x); storage.removeItem(x); return true; } catch(e) { return e instanceof DOMException && ( // everything except Firefox e.code === 22 || // Firefox e.code === 1014 || // test name field too, because code might not be present // everything except Firefox e.name === 'QuotaExceededError' || // Firefox e.name === 'NS_ERROR_DOM_QUOTA_REACHED') && // acknowledge QuotaExceededError only if there's something already stored (storage && storage.length !== 0); }}//使用时判断if (storageAvailable('localStorage')) { // Yippee! We can use localStorage awesomeness}else { // Too bad, no localStorage for us} 从存储中设置/获取/删除值 //设置local storage的font键值对localStorage.setItem('font', document.getElementById('font').value);//设置local storage的json键值对var data = { name:'xiecanyong', sex:'man', hobby:'program'};var d = JSON.stringify(data); //json字符串化localStorage.setItem(\"data\",d);//获取local storage的font键值对var currentFont = localStorage.getItem('font'); //获取local storage的json键值对var json = localStorage.getItem(\"data\");var jsonObj = JSON.parse(json);//删除local storage的font键值对localStorage.removeItem('font'); //删除local storage的全部内容localStorage.clear(); Session StorageSession Storage与Local Storage很类似，只不过localStorage里面存储的数据没有过期时间设置，而Session Storage只用于存储当前会话的数据，当会话结束后，Session Storage的数据会随之销毁。 sessionStorage中一般浏览器支持的也是5M大小 测试localStorage、sessionStorage在浏览器中支持的存储大小 页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话 在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点和 session cookies 的运行方式不同 打开多个相同的URL的Tabs页面，会创建各自的sessionStorage 关闭对应浏览器tab，会清除对应的sessionStorage 使用测试可用性 //测试函数function storageAvailable(type) { var storage; try { storage = window[type]; var x = '__storage_test__'; storage.setItem(x, x); storage.removeItem(x); return true; } catch(e) { return e instanceof DOMException && ( // everything except Firefox e.code === 22 || // Firefox e.code === 1014 || // test name field too, because code might not be present // everything except Firefox e.name === 'QuotaExceededError' || // Firefox e.name === 'NS_ERROR_DOM_QUOTA_REACHED') && // acknowledge QuotaExceededError only if there's something already stored (storage && storage.length !== 0); }}//使用时判断if (storageAvailable('localStorage')) { // Yippee! We can use localStorage awesomeness}else { // Too bad, no localStorage for us} 从存储中设置/获取/删除值 //设置session storage的font键值对sessionStorage.setItem('font', document.getElementById('font').value);//设置session storage的json键值对var data = { name:'xiecanyong', sex:'man', hobby:'program'};var d = JSON.stringify(data); //json字符串化sessionStorage.setItem(\"data\",d);//获取session storage的font键值对var currentFont = sessionStorage.getItem('font'); //获取session storage的json键值对var json = sessionStorage.getItem(\"data\");var jsonObj = JSON.parse(json);//删除session storage的font键值对sessionStorage.removeItem('font'); //删除session storage的全部内容sessionStorage.clear(); Local Storage 与 Session Storage统称为Web Storage Cookies 这里的Cookies也叫Http Cookie、Web Cookie、浏览器Cookie，是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能 Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 这里先记录Cookies在Angular下的使用，其实也是一样的，只不过等一下记录的那个是经过封装过的 使用 先安装ngx-cookie-service的npm包 npm i ngx-cookie-service 在app.modules.ts那里注入服务 @NgModule({ declarations: [AppComponent], entryComponents: [], imports: [ //import modules ], providers: [ CookieService, //import providers ], bootstrap: [AppComponent]})export class AppModule {} 在构造函数中声明CookieService变量 export class AcotPage { constructor( private cookieService:CookieService, ) {}} 从存储中设置/获取/删除值 //set 函数/** * @param name Cookie name * @param value Cookie value * @param expires Number of days until the cookies expires or an actual `Date` * @param path Cookie path * @param domain Cookie domain * @param secure Secure flag * @param sameSite OWASP samesite token `Lax`, `None`, or `Strict`. Defaults to `Lax` */set(name: string, value: string, expires?: number | Date, path?: string, domain?: string, secure?: boolean, sameSite?: 'Lax' | 'None' | 'Strict'): void;//设置Cookies键值对 此时设置的有效时间为7天this.cookieService.set(\"name\",\"value\",7);//get 函数/** * @param name Cookie name * @returns property value */get(name: string): string;//获取Cookies值let value=this.cookieService.get(\"name\");//check 函数/** * @param name Cookie name * @returns boolean - whether cookie with specified name exists */check(name: string): boolean;//delete 函数/** * @param name Cookie name * @param path Cookie path * @param domain Cookie domain */delete(name: string, path?: string, domain?: string, secure?: boolean, sameSite?: 'Lax' | 'None' | 'Strict'): void; 参考：1.Maze的前端常用缓存技术2.MDN 使用 Web Storage API3.MDN sessionStorage4.梦殇918的sessionStorage详解5.MDN 使用 Web Storage API6.MDN http cookies","permalink":"https://wakie01.github.io/2020/09/10/1625/","photos":[]},{"tags":[{"name":"CORS","slug":"CORS","permalink":"https://wakie01.github.io/tags/CORS/"}],"title":"Chrome跨域时的Cookie问题","date":"2020/08/23","text":"最近突然发现一个问题，之前前端访问后端时都没问题，最近突然出问题了！！ 一开始我还想是跨域问题吗？是Cookie跨域？每次访问后端时，所获取的Session ID都不一样，可是这些CORS我都配置好了 而且Chrome的DevTools也没显示什么问题，仿佛一切正常 发呆了很久。。。。。。。。。。 终于注意到Set-Cookie处的感叹号 ❗ 那里显示 this set-cookie didn’t specify a “SameSite” attribute…… 然后就一通查询啊，发现CHROME 80版本以后，SAMESITE COOKIE验证跨站问题 具体什么鬼我还没弄清楚， 然后经过一番无脑操作，就OK了 chrome浏览器中搜索下面地址：chrome://flags/#same-site-by-default-cookieschrome://flags/#cookies-without-same-site-must-be-secure这两项设置为Disabled，并重启浏览器 最后我用Edge试一下，发现一切正常，估计这是Chrome新出的什么防爬虫规则","permalink":"https://wakie01.github.io/2020/08/23/1137/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"java解析和编辑Excel文件","date":"2020/08/21","text":"Java解析Excel文件常用Apache的POI Maven导入Jar包 org.apache.poi poi-ooxml 4.1.0 解析简单表先来个解析类似这样的简单表 代码 @PostMapping(\"/importExcel\")public List importExcel(@RequestParam(\"excelFile\") MultipartFile excelFile){ List returnList=new ArrayList(); try { InputStream inputStream=excelFile.getInputStream(); //根据inputStream的类型自动建立 HSSFWorkbook 或 XSSFWorkbook的 Workbook对象 //其中HSSFWorkbook用来解析xls格式的excel，XSSFWorkbook用来解析xlsx格式的excel Workbook workbook=WorkbookFactory.create(inputStream); Sheet sheet=workbook.getSheetAt(0); //获取表格对象 int rowNum=sheet.getPhysicalNumberOfRows(); //获取表格行数 int colNum=sheet.getRow(0).getPhysicalNumberOfCells(); //获取表格第一行的列数 //从第二行开始解析 //由于数据量过多，chrome的DevTools显示不了，所以先来99个 for(int i=1;i","permalink":"https://wakie01.github.io/2020/08/21/2242/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"java数据类型转换","date":"2020/08/20","text":"我今天发现一个有趣的数据类型转换，特地记录一下 数字转String String str=0.13+\"\"; //输出0.13String str=0+\"\"; //输出0","permalink":"https://wakie01.github.io/2020/08/20/1232/","photos":[]},{"tags":[{"name":"Http","slug":"Http","permalink":"https://wakie01.github.io/tags/Http/"}],"title":"浏览器缓存学习","date":"2020/08/13","text":"概述浏览器缓存，也叫Http缓存，其机制是根据HTTP报文的缓存标识进行的 其缓存过程是这样的：当浏览器第一次向服务器发起请求，拿到请求结果后，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是，则将请求结果和缓存标识存入浏览器缓存中 其中，根据验证缓存是否有效的方式上，是将缓存过程分为两个部分，分别是 强制缓存 和 协商缓存 强制缓存在第一次访问服务器取到数据之后，在过期时间之内不会再去重复请求，在过期时间内重复请求，会返回200状态码，并且这状态码为灰色，size那里会显示memory cache或disk cache 流程图 强缓存失效 强缓存有效 缓存规则 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。 ExpiresExpires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。 但，现在浏览器默认使用的是HTTP/1.1， 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效 比如这个，我打开博客的时间是2020/08/13 23:00左右，而服务器那边设置的Expires时间是这个，很明显不合理，毕竟这个github的服务器当前在荷兰 但，为了兼容HTTP/1.0，还是会将Expire设置上 Cache-ControlCache-Control是HTTP/1.1控制网页缓存的字段，其主要取值为： public： 客户端和代理服务器都可缓存内容 private： 客户端可以缓存内容，代理服务器不可以，Cache-Control的默认取值 no-cache： 客户端可以缓存内容，不用强制缓存，直接走协商缓存 no-store： 全都不用缓存 max-age=xxx： 缓存内容将在xxx秒后失效 常见用法：cache-control: max-age=xxxx,publiccache-control: no-cache 如上图显示，响应头的缓存规则是：在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效，而age的作用是计时，当前距上一次请求已过了43秒，可是 这里的状态码是304，显示用的是协商缓存，为什么呢？ Cache-Control在请求头与响应头中的作用 在请求头： 通知服务器自己用什么强制缓存规则，比如no-cache、max-age=0，告诉服务器自己直接走协商缓存 在响应头： 通知浏览器可以用什么强制缓存规则，当然浏览器可以选择不用，比如max-age=600，告诉浏览器600s内可直接使用强制缓存 协商缓存在第一次访问服务器取到数据之后，每次读取数据时都需要跟服务器通信，向服务器发送的是缓存标识，用来验证缓存内容是否没变。没变，服务器则返回304状态码，浏览器就读取本地缓存数据变，服务器会将新数据和新的缓存标识一起返回到浏览器，然后浏览器更新缓存标识，此时状态码是200 流程图 协商缓存生效，返回304 协商缓存失效，返回200和请求结果结果 例子 由上图可知，有个304状态码也是灰色的，并且在那旁边会显示from memory cache或from disk cache 那不是灰色的304又是怎么回事呢？不是灰色的话，旁边没有from memory cache或from disk cache（待解决） Last-Modified / If-Modified-SinceLast-Modified / If-Modified-Since 是HTTP/1.0控制网页缓存的字段 Last-Modified： 服务器响应请求时，返回该资源文件在服务器最后被修改的时间 If-Modified-Since： 客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件 Etag / If-None-MatchEtag / If-None-Match 是HTTP/1.1控制网页缓存的字段 Etag： 服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成) If-None-Match： 是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200 Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。其实就是HTTP/1.1优先级高于HTTP/1.0 到这里，我就有个疑问❓了，服务器该怎么验证这个标识值有没有改变呢？重新获取一次资源，然后计算该资源的标识值，然后对比？若是一样的话，就告诉浏览器使用缓存即可，不同就把资源传给浏览器？这样的话又快在哪里呢？（待解决） 两者关系当浏览器两种缓存机制都用时，浏览器会先用强制缓存，当强制缓存失效时，再使用协商缓存 优缺点 优点： 减少不必要的数据传输，节省带宽；减少服务器负担，提升网站性能；加快客户端加载网页的速度，用户体验友好 缺点： 服务端资源更新后，客户端更新滞后 总结强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存 最后的最后，这个Http缓存在一般的前后端分离的应用中该怎么应用呢？这又是另一篇章了 参考：1.heyingye的博文2.Thomas赵骐的博文3.Cedric’s Blog4.sliiva blog5.蜗牛1T blog","permalink":"https://wakie01.github.io/2020/08/13/1518/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"java实现文件的上传与下载","date":"2020/08/12","text":"上传后端 @PostMapping(\"/uploadFile\")public void uploadFile(@RequestParam(\"fileName\") MultipartFile file){ File newFile=new File(\"D:/Java workspace/filedemo/src/main/resources/static/files/\"+file.getOriginalFilename()); try { InputStream in=file.getInputStream(); FileOutputStream out=new FileOutputStream(newFile); byte[] bytes=new byte[1024*4]; int len; while((len=in.read(bytes))!=-1){ out.write(bytes,0,len); } in.close(); out.close(); } catch (IOException e) { e.printStackTrace(); }} 对于spring项目，还要对上传文件的大小作限制，如限制30MB： spring.servlet.multipart.max-file-size=30MBspring.servlet.multipart.max-request-size=30MB 上传文件到服务器某个位置不难，难的是对文件做相应的解析 下载@GetMapping(\"/fileTest\")public void fileTest(HttpServletResponse response){ File file=new File(\"D:/Java workspace/filedemo/src/main/resources/static/files/java实现文件的上传与下载.md\"); try { FileInputStream fileInput=new FileInputStream(file); OutputStream out=response.getOutputStream(); response.setContentType(\"application/octet-stream\"); //告诉浏览器这是要下载的 response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + file.getName()); byte[] bytes=new byte[1024*4]; int len; while((len=fileInput.read(bytes))!=-1){ out.write(bytes,0,len); } fileInput.close(); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }} Content-Type设置 Content-Type应设置为： application/x-msdownload 或 application/octet-stream 不过，据说Mac的Safari对application/x-msdownload的支持不佳 其中application/octet-stream，这是应用程序文件的默认值。对于未知的应用程序文件 ，浏览器一般不会自动执行或询问执行。浏览器会像对待设置了HTTP头Content-Disposition 值为 attachment 的文件一样来对待这类文件。 那么application/octet-stream 对于常见的如.txt文件会怎样呢？测试了一下，结果还是一样，弹出的下载框所显示的文件类型还是 . Header设置 对于Content-Type应设置为： application/x-msdownload的，需要设置Content-Disposition 为 attachment，后面的filename是附带的，是用来初始化下载框的文件名，可要可不要 这里attachment只是Content-Disposition的一种属性，具体可看MDN web docs关于Content-Disposition的介绍 而对于Content-Type应设置为： application/octet-stream的，可不用设置，因为它已经默认Content-Disposition 为 attachment 最后在网络上文件的传送绝大部分都是以binary的形式传送 参考：1.lizeyang博文2.MDN web docs","permalink":"https://wakie01.github.io/2020/08/12/2123/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"Java中的抽象类与接口","date":"2020/08/07","text":"抽象类抽象类是用来捕捉子类的通用特性的，它不能被实例化，只能被子类继承extend，抽象类相当于一个模板 抽象类里有抽象方法（没有内容），也可有普通正常的方法（有内容） 抽象类只能设置为public,抽象类中的抽象方法可设为public或protected,其它方法则没限制 例子 //抽象类Animalpublic abstract class Animal { Animal() { System.out.println(\"I'm animal\"); } public abstract void eat(); public abstract void sleep(); public void walk() { System.out.println(\"animal walking\"); } public static void say() { System.out.println(\"animal saying\"); } }//继承抽象类Animalpublic class Person extends Animal { @Override public void eat() { System.out.println(\"person eating\"); } @Override public void sleep() { System.out.println(\"person sleeping\"); }}public class Main { public static void main(String[] args) { Animal.say(); Person person=new Person(); person.walk(); person.eat(); person.sleep(); }} ## 结果animal sayingI'm animalanimal walkingperson eatingperson sleeping 可能因为Java规定子类最多只能继承extend一个父类，所以出现 接口 这东西 接口在Java中，类可以实现implement多个接口 接口中只有抽象方法，所以方法中的 abstract 一般会不写， 接口以及接口中的方法只能设为public 接口可以实例化 接口速度相对抽象类来说较慢，因为它需要时间去寻找在类中实现的方法 例子 public interface Animal { void eat(); //默认public，也只能public void sleep();}public interface Student { void learn();}//实现两个接口public class Person implements Animal,Student{ @Override public void eat() { System.out.println(\"person eatting\"); } @Override public void sleep() { System.out.println(\"person sleeping\"); } @Override public void learn() { System.out.println(\"person learning\"); }}public class Main { public static void main(String[] args) { Animal person=new Person(); person.eat(); person.sleep(); //person.learn(); 报错，因为 person是Animal的实例 }} 区别 抽象类 接口 方法 有抽象方法、普通方法、静态方法 只有抽象方法 实现 只能extend一个抽象类 可implement多个接口 Constructor 可有 不能有 访问修饰符 类：public；方法：public、protected 类与方法：public main方法 可有 不能有 速度 比接口快 较慢 添加新方法 若非添加抽象方法,可不用改变子类代码 需改变实现类的代码 选择 若拥有一些方法，且想让他们默认实现，则使用抽象类 想继承多个，则使用接口 若基本功能不断改变，则使用抽象类 参考：1.至尊宝博文","permalink":"https://wakie01.github.io/2020/08/07/1843/","photos":[]},{"tags":[{"name":"jdbc","slug":"jdbc","permalink":"https://wakie01.github.io/tags/jdbc/"},{"name":"mysql","slug":"mysql","permalink":"https://wakie01.github.io/tags/mysql/"}],"title":"JDBC的Statement与PrepareStatement","date":"2020/08/04","text":"二者区别Statement 执行每一条SQL语句时，都是编译+执行，相当于静态SQL PrepareStatement 执行的SQL语句，会进行预编译，SQL中可以包含动态参数，在执行时可以设置动态参数，当下次执行相同类型的SQL语句时，可以解析并直接执行编译好的SQL语句，从而减少编译次数提高数据库的性能，相当于动态SQL 选择若只执行一次，或执行极少次的sql语句，一般会使用 Statement ，开销小 若批量执行同类型sql语句，则会使用 PrepareStatement Statement使用 Connection connection;try { Class.forName(\"com.mysql.cj.jdbc.Driver\"); String url=\"jdbc:mysql://localhost:3306/job_spider?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai\"; connection=DriverManager.getConnection(url,\"root\",\"wakie\"); Statement statement=connection.createStatement(); for(int i=0;i","permalink":"https://wakie01.github.io/2020/08/04/2243/","photos":[]},{"tags":[{"name":"华为班","slug":"华为班","permalink":"https://wakie01.github.io/tags/%E5%8D%8E%E4%B8%BA%E7%8F%AD/"}],"title":"华为班面试","date":"2020/08/03","text":"前言前几天参加了个华为班面试，然后被问得一脸茫然，回想记录一下面试官的问题 Q&A 多线程 数据库批量插入 A：一开始我还以为他问的是批量插入的sql语句，后来百度一下才知道，原来没有什么批量插入的sql语句，都是多次使用insert语句来实现批量插入的，其中Java常用PrepareStatement来实现 Get方法与Post方法的区别，二者在向后端传数据时有什么限制与不同吗 Java中抽象类与接口类的有什么同与不同 A：之前没什么接触抽象类，但其实自己经常接触，只是没发觉，抽象类还是很厉害的，Java中的抽象类与接口 JDBC中Statement与PrepareStatement有什么区别 A：JDBC的Statement与PrepareStatement的区别 同步与异步的区别 最后","permalink":"https://wakie01.github.io/2020/08/03/1617/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"},{"name":"Json","slug":"Json","permalink":"https://wakie01.github.io/tags/Json/"}],"title":"FastJSON使用","date":"2020/07/28","text":"前言用了一段时间阿里的FastJSON后，感觉挺好用的，特此记录一下，其实也很简单 上手1. Maven com.alibaba fastjson 1.2.31 2. 常见用法 对String能否转成JSONObject进行判断 String str=new String(\"111\");JSONObject jsonObject;try { jsonObject= JSON.parseObject(str);}catch (JSONException e1){ return false;}catch (ClassCastException e2){ return false;}return true; 将String转成JSONObject JSONObject jsonObject=JSON.parseObject(str);//JSONObject jsonObject=JSONObject.parseObject(str); 效果一样jsonObject.getInteger(\"year\"); jsonObject.containsKey(\"month\");jsonObject.put(\"date\",\"07/28\");jsonObject.getJSONObject(\"time\");","permalink":"https://wakie01.github.io/2020/07/28/1045/","photos":[]},{"tags":[{"name":"SSH","slug":"SSH","permalink":"https://wakie01.github.io/tags/SSH/"}],"title":"SSH整理","date":"2020/07/26","text":"前言之前在用Putty连接服务器时就见过SSH，只觉得它是用来保证安全connect & communicate的，一直没认真了解过，最近在学Hadoop时又遇到了它，于是…… SSH是？SSH全称：Secure Shell，又称：安全外壳协议 由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为 远程登录会话 和 其他网络服务 提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 之前互联网通信都是明文通信，一旦被截获，内容就会暴露，如ftp、pop和telnet，所以现在基本不怎么用telnet，而SSH保证即使截获，也不会暴露内容。 SSH只是一种协议，有多种实现，商业的，开源的。 安全机制1. 基于口令的安全验证 通过账号、密码登录，然后所有传输的数据都会被加密， 原来之前我登录服务器都是用这个的 2. 基于密匙的安全验证 远程主机收到用户的登录请求，把自己的公钥发给用户 用户使用这个公钥，将登录密码加密后，发送回来 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录 非对称加密 这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪 至于这些公钥私钥，常见的是用户自己生成的。 有什么好？ 加密，安全 传输的数据是经过压缩的，所以可以加快传输的速度 区别SSH框架与SSH协议同缩写的还有一个是SSH框架，难怪我觉得乱！SSH框架是指：Struts+Spring+Hibernate，不过现在新开发的网页中基本没什么人用SSH框架了 参考： SSH协议百度百科 Jack LDZ博文 awesome_go博文","permalink":"https://wakie01.github.io/2020/07/26/2300/","photos":[]},{"tags":[{"name":"Http","slug":"Http","permalink":"https://wakie01.github.io/tags/Http/"}],"title":"Http请求body类型","date":"2020/07/24","text":"body类型常见的有： none form-data x-www-urlencoded raw binary none不传送数据 form-data传送表单数据，Headers的Content-Type为multipart/form-data 比如前台传送 那么后台要这样接收 (以spring boot为例) x-www-urlencodedurlencode，顾名思义，就是url编码，将表单数据以url编码后传送，具体编码后的样子是，比如，传送 那么后台收到的数据形式就会是：msg=hello world&status=success 即表单内的数据转换为键值对 此时Headers的Content-Type为application/x-www-form-urlencoded form-data与x-www-urlencoded有什么不同？ (以spring boot为例)form-data: 不能用@RequestBody直接接收，而是得用@RequestParam来一个一个接收,而且接收数据的名字要对应，不然会出错x-www-urlencoded: 可以直接用@RequestBody接收 rawRaw(原始),可以传送任意格式的文本，比如text、json、xml、html等 最常见就是传送json数据，而此时Headers的Content-Type为application/json binary上传二进制数据，常用来传送文件数据，一次只能上传一个文件 不同文件类型，http Headers的Content-Type也会不同，比如： 文件类型 Content-Type .text text/plain .json application/json .sql application/x-sql .doc application/msword .xls application/vnd.ms-excel .mp3 audio/mpeg","permalink":"https://wakie01.github.io/2020/07/24/1158/","photos":[]},{"tags":[{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"}],"title":"java与javaw命令","date":"2020/07/20","text":"前言之前运行jar包，都是使用下面命令 java -jar xxx.jar 今天接触到另一种：javaw ，记录一下 笔记javaw运行jar包也是类似： javaw -jar xxx.jar 两者对比 java 在cmd命令窗口运行，并占据这个命令窗口，属于阻塞程序，可用Ctrl+C结束 javaw 在cmd命令窗口运行，但并不占据这个命令窗口，在运行这条命令后可继续运行其它命令，相当于在后台运行，属于非阻塞程序，不可用Ctrl+C结束，但可在任务窗口结束进程 总结都差不多，效果是一样的，不过据说javaw好像比java的反应速度慢一点","permalink":"https://wakie01.github.io/2020/07/20/1428/","photos":[]},{"tags":[{"name":"mysql","slug":"mysql","permalink":"https://wakie01.github.io/tags/mysql/"}],"title":"Mysql数据长度设置","date":"2020/07/10","text":"前言最近在弄数据库，由于数据库非常地庞大，所以什么都要精打细算。于是对数据库数据设置长度感兴趣起来。 What’s itint类型对于int类型，如果不设置填充零的话，这个长度基本上是没啥用的 MySQL的int类型默认是32位，数据范围：-2147483648 ~ 2147483647 若设置填充零的话，它的数据范围还是：-2147483648 ~ 2147483647 不同的是，这个长度设置的是数据的显示长度，长度不够？没关系，用0补。长度超了？没关系，数据还是这么长。举个例子： A设置了int(5),然后A添加数据100，然后A的数据框会显示00100；当A添加数据12345678，A的数据框会显示的还是12345678 varchar类型对于varchar类型，这个长度就很有用了，它指的是字符串的可最大长度","permalink":"https://wakie01.github.io/2020/07/10/1731/","photos":[]},{"tags":[{"name":"Npm","slug":"Npm","permalink":"https://wakie01.github.io/tags/Npm/"}],"title":"npm使用","date":"2020/06/22","text":"前言使用了大半年了Npm，一直都对它模模糊糊，今天对其整理一下。 Npm（Node Package Manager）是一个包管理工具，在安装Node.js时会自动安装好，它很方便让JavaScript开发者下载、安装、上传以及管理已经安装的包。 一般命令 查看Npm版本 $ npm -v 查看Npm全局目录 $ npm root -g 初始Npm项目 一般cd到项目根目录，然后执行下面命令 $ npm init 其运行结果： 在配置过程中，直接按回车表示默认 快速初始命令： $ npm init -y -y 表示在初始项目时，Package.json文件的各种参数采用默认值，之后可以自己慢慢改 初始完成后，会在该初始目录下新建package.json文件： 其中package.json文件中的 \"scripts\":{ \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"} 是npm的一些小脚本，”test”是脚本名字，后面是其内容,当输入 $ npm test 会运行该脚本，此时结果是输出”Error: no test specified” 常用命令安装Package$ npm install [package name]$ npm i [package name] ##简写 该命令默认安装当前Package的最新版本，当需要安装某一个版本时，可在[package name]后添加@[版本] 当安装的Package已存在，将自动替换掉已有的Package 查找Package可到Npm官网 当非全局安装Package完成后，该项目会出现node_modules文件夹，存放Package，同时package.json文件也会变动 npm install常见后缀 无后缀 默认安装到生产环境中，在package.json中可见 \"dependencies\": { //\"包名\": \"版本号\" \"bootstrap\": \"^4.5.0\", \"jquery\": \"^3.5.1\"} -g $ npm install -g [package name] 全局安装，安装的包放在全局目录下，并且可以直接在命令行里使用。 --save $ npm install --save [package name] 效果跟无后缀一样 --save-dev $ npm install --save-dev [package name] 安装到开发环境中，在package.json中可见 \"devDependencies\": { //\"包名\": \"版本号\" \"primeng\": \"^9.1.0\"} 生产环境：正式提供对外服务的环境 开发环境： 删除Package$ npm uninstall [package name] 非全局删除Package，即删除项目中node_modules文件夹中的Package，同时package.json文件也会变动 npm install常见后缀 -g $ npm uninstall -g [package name] 全局删除 无后缀 本地删除，删除的是生产依赖，所以package.json中的dependencies会变动 --save $ npm uninstall --save [package name] 同无后缀 --save-dev $ npm uninstall --save-dev [package name] 本地删除，删除的是开发依赖，所以package.json中的devdependencies会变动 安装package.json文件的依赖$ npm install 当有了package.json文件，执行上面命令将自动下载项目的各种依赖。","permalink":"https://wakie01.github.io/2020/06/22/0911/","photos":[]},{"tags":[{"name":"git","slug":"git","permalink":"https://wakie01.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://wakie01.github.io/tags/github/"}],"title":"git&github使用","date":"2020/06/18","text":"前言记录一下这段时间关于Git&GitHub的学习 常用命令 本地库初始化 $ git init 查看工作区、暂存区状态 $ git status 将工作区中新建/修改的文件添加到暂存区 $ git add [file_name] ​ 常用git add .来将所有修改或新建的文件添加到暂存区 将暂存区的内容提交到本地库 $ git commit -m \"message\" [file_name] 查看commit的历史记录HEAD是一个指针，表示当前版本 比较详细的 $ git log 空格 向下翻页 ； b 向上翻页 ； q 退出 比较简洁 $ git log --pretty=oneline 更简洁（将Hash值，也叫索引值缩短显示） $ git log --oneline 比较简洁 $ git log --oneline HEAD@{移动到该版本需要多少步数} commit版本的前进后退reset命令在 –hard参数 下，工作区、暂存库和本地库会同时发生改变。 基于索引值操作 $ git reset --hard [索引值] 可前可后 使用^符号 $ git reset --hard HEAD^ 只能后退，一个^表示后退一步，n个^表示后退n步 使用~符号 $ git reset --hard HEAD~n 只能后退，~n表示后退n步 比较文件差异 将工作区的文件与暂存区的进行比较 $ git diff [file_name] 将工作区的文件与本地库中某历史版本的进行比较 $ git diff [历史版本索引值] [file_name] 分支管理 创建分支 $ git branch [分支名] 查看分支 $ git branch -v 切换分支 $ git checkout [分支名] 合并分支 切换到接收修改的分支 $ git checkout [被合并分支名] 合并 $ git merge [要合并分支名] 解决冲突（若有） 编辑文件，删除特殊符号 修改文件，保存退出 添加到暂存区 $ git add [文件名] 提交到本地库 $ git commit -m \"message\" 远程库(Github) 添加远程库 $ git remote add [别名] [远程地址] 查看远程库 $ git remote -v 删除远程库 $ git remote rm [别名] 将本地库推送到远程库 $ git push [别名] [分支名] 将远程库克隆到本地库 $ git clone [远程地址] 注意：克隆时会将别人的本地库也克隆下来 拉取 ## pull=fetch+merge$ git fetch [别名] [远程分支名]$ git merge [别名] [远程分支名]$ git pull [别名] [远程分支名] 结言了解一下，虽然现在都是图形化界面","permalink":"https://wakie01.github.io/2020/06/18/1032/","photos":[]},{"tags":[{"name":"Ionic4","slug":"Ionic4","permalink":"https://wakie01.github.io/tags/Ionic4/"},{"name":"Dom","slug":"Dom","permalink":"https://wakie01.github.io/tags/Dom/"}],"title":"Ionic4获取窗口及组件高度","date":"2020/06/12","text":"前言js获取窗口和组件的style高度的方法有很多 具体有js中如何获取元素的高度 还有这个js中获取窗口高度的 我的实践 typescript代码 ionViewDidEnter(){ let header_wea=document.getElementById(\"header_wea\"); let segment_wea=document.getElementById(\"segment_wea\"); let height1=document.body.clientHeight; //BODY对象高度 let height2=document.documentElement.clientHeight; //窗口可见区域高 console.log(\"height1: \",height1); console.log(\"height2: \",height2); let headerHeight=header_wea.clientHeight; //组件(内容)可见区域高 let segmentHeight=segment_wea.clientHeight; console.log(\"headerHeight: \",headerHeight); console.log(\"segmentHeight: \",segmentHeight); let height3=header_wea.style.height; //需要显式设置style的height属性才能获取到高度 let height4=segment_wea.style.height; console.log(\"height3: \",height3); console.log(\"height4: \",height4); let height5=window.getComputedStyle(header_wea).height; //获取当前元素所有最终使用的CSS属性值 let height6=window.getComputedStyle(segment_wea).height; console.log(\"height5: \",height5); console.log(\"height6: \",height6); let height7=header_wea.offsetHeight; //跟clientHeight差不多，感觉都是组件(内容)可见区域高 let height8=segment_wea.offsetHeight; console.log(\"height7: \",height7); console.log(\"height8: \",height8);} 运行结果 最终采用ionViewDidEnter(){ let height1=document.body.clientHeight; let header_wea=document.getElementById(\"header_wea\"); let segment_wea=document.getElementById(\"segment_wea\"); let headerHeight=header_wea.clientHeight; let segmentHeight=segment_wea.clientHeight; document.getElementById(\"iframe_wea\").style.height=height1-headerHeight-segmentHeight+\"px\";}","permalink":"https://wakie01.github.io/2020/06/12/1104/","photos":[]},{"tags":[{"name":"git","slug":"git","permalink":"https://wakie01.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://wakie01.github.io/tags/hexo/"}],"title":"hexo博客关于theme的git上传问题","date":"2020/06/11","text":"前言 记录一下在部署Hexo博客时的git问题 问题最近在对Hexo博客源代码的上传时碰到一点问题，theme目录下的hexo-theme-huhu文件夹push不上去 输入 $ git status 结果 原因 之前在克隆别人的theme时，那个theme已经init了git，那个hexo-theme-huhu文件夹里有.git/的文件夹 解决一般情况 将themes/hexo-theme-huhu/.git文件夹删除 重新添加该文件夹到git暂存区 $ git add themes/hexo-theme-huhu 将该文件夹提交到本地库 $ git commit -m \"commit message\" themes/hexo-theme-huhu 上传到GitHub $ git push 我的情况当我删除了themes/hexo-theme-huhu/.git文件夹，再重新添加该文件夹到git暂存区时，结果显示不需要添加，提交到本地库时也是显示不需要提交 原因： 由于我之前已经将该文件夹push了上去，不过虽然我push了上去，可是在GitHub上那个文件夹是打不开的。 我的解决方法 清除git关于hexo-theme-huhu分支上的文件 $ git rm --cache theme/hexo-theme-huhu 上传到GitHub,覆盖原来的版本 $ git push 将themes/hexo-theme-huhu/.git文件夹删除 这是输入 $ git status 会显示 重新添加该文件夹到git暂存区 $ git add themes/hexo-theme-huhu 将该文件夹提交到本地库 $ git commit -m \"commit message\" themes/hexo-theme-huhu 上传到GitHub $ git push","permalink":"https://wakie01.github.io/2020/06/11/2138/","photos":[]},{"tags":[{"name":"Ionic4","slug":"Ionic4","permalink":"https://wakie01.github.io/tags/Ionic4/"},{"name":"Android","slug":"Android","permalink":"https://wakie01.github.io/tags/Android/"}],"title":"Ionic4 打包成Android APK","date":"2020/06/10","text":"前言 向学长学习，我也开始学着自己写博客。 之前在做毕业设计时，遇到了很多问题，现在有空我准备将这些问题一一整理下。 今天先写个关于Ionic4打包成Android APK的 步骤这里我使用Android Studio打包Apk Ionic 构建ionic build 作用：ionic build will perform an Ionic build, which compiles web assets and prepares them for deployment. 之前因为没这步骤，ionic部署到安卓后运行不了，显示net:error_connection refuse，或net:error_file_not_found(file:///android_asset/www/index.html) 错误 Android 平台构建ionic cordova platform add android 注意：如果Android platform 已存在，则需先执行下面命令将以前的platform清除 ionic cordova platform rm android 修改网络安全配置文件未修改的话会出现ERR_ClEARTEXT_NOT_PERMITTED错误 原因：Android9.0对未加密的流量不再信任，添加了新的限制。Google表示，为保证用户数据和设备的安全，针对下一代 Android 系统(Android P) 的应用程序，将要求默认使用加密连接，这意味着 Android P 将禁止 App 使用所有未加密的连接，因此运行 Android P 系统的安卓设备无论是接收或者发送流量，未来都不能明码传输，需要使用下一代(Transport Layer Security)传输层安全协议，而 Android Nougat 和 Oreo 则不受影响。 解决方法：在项目名/platforms/android/app/src/main/res/xml/network_securiy_config.xml文件中内容修改为如下 然后在项目名/platforms/android/app/src/main/AndroidManifest.xml引用： 其它解决方法：Android版本降级、修改服务端，将http协议转换为https协议 打包APK用Android Studio打开 项目名/platforms/android 的文件夹 在gradle sync提示框中点击OK 问题：有时会出现gradle sync失败 解决方法：修改build.gradle文件中的gradle版本为当前android studio所使用的gradle版本，比如我android studio使用的gradle版本是4.0.0 需要改应用名称时，可打开res/values/string.xml文件对app_name处进行修改 点击Build/Build Bundle(s) apk(s)/Build apk 即可 最后会就简单，不会就满是坑🕳","permalink":"https://wakie01.github.io/2020/06/10/2139/","photos":[]},{"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wakie01.github.io/tags/Hexo/"}],"title":"Hello World","date":"2020/06/09","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","permalink":"https://wakie01.github.io/2020/06/09/2139/","photos":[]}],"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wakie01.github.io/tags/Linux/"},{"name":"linux","slug":"linux","permalink":"https://wakie01.github.io/tags/linux/"},{"name":"Java","slug":"Java","permalink":"https://wakie01.github.io/tags/Java/"},{"name":"PS","slug":"PS","permalink":"https://wakie01.github.io/tags/PS/"},{"name":"Time","slug":"Time","permalink":"https://wakie01.github.io/tags/Time/"},{"name":"Mysql","slug":"Mysql","permalink":"https://wakie01.github.io/tags/Mysql/"},{"name":"AI","slug":"AI","permalink":"https://wakie01.github.io/tags/AI/"},{"name":"java","slug":"java","permalink":"https://wakie01.github.io/tags/java/"},{"name":"Nginx","slug":"Nginx","permalink":"https://wakie01.github.io/tags/Nginx/"},{"name":"代理","slug":"代理","permalink":"https://wakie01.github.io/tags/%E4%BB%A3%E7%90%86/"},{"name":"前端","slug":"前端","permalink":"https://wakie01.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"跨域","slug":"跨域","permalink":"https://wakie01.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"Typescript","slug":"Typescript","permalink":"https://wakie01.github.io/tags/Typescript/"},{"name":"ML","slug":"ML","permalink":"https://wakie01.github.io/tags/ML/"},{"name":"Cache","slug":"Cache","permalink":"https://wakie01.github.io/tags/Cache/"},{"name":"CORS","slug":"CORS","permalink":"https://wakie01.github.io/tags/CORS/"},{"name":"Http","slug":"Http","permalink":"https://wakie01.github.io/tags/Http/"},{"name":"jdbc","slug":"jdbc","permalink":"https://wakie01.github.io/tags/jdbc/"},{"name":"mysql","slug":"mysql","permalink":"https://wakie01.github.io/tags/mysql/"},{"name":"华为班","slug":"华为班","permalink":"https://wakie01.github.io/tags/%E5%8D%8E%E4%B8%BA%E7%8F%AD/"},{"name":"Json","slug":"Json","permalink":"https://wakie01.github.io/tags/Json/"},{"name":"SSH","slug":"SSH","permalink":"https://wakie01.github.io/tags/SSH/"},{"name":"Npm","slug":"Npm","permalink":"https://wakie01.github.io/tags/Npm/"},{"name":"git","slug":"git","permalink":"https://wakie01.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://wakie01.github.io/tags/github/"},{"name":"Ionic4","slug":"Ionic4","permalink":"https://wakie01.github.io/tags/Ionic4/"},{"name":"Dom","slug":"Dom","permalink":"https://wakie01.github.io/tags/Dom/"},{"name":"hexo","slug":"hexo","permalink":"https://wakie01.github.io/tags/hexo/"},{"name":"Android","slug":"Android","permalink":"https://wakie01.github.io/tags/Android/"},{"name":"Hexo","slug":"Hexo","permalink":"https://wakie01.github.io/tags/Hexo/"}]}